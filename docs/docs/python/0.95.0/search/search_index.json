{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\ud83c\udfe1 Home","text":"StreamPipes is a self-service (Industrial) IoT toolbox to enable non-technical users to connect, analyze and explore IoT data streams. Apache StreamPipes for Python \ud83d\udc0d <p> Apache StreamPipes meets Python! We are working highly motivated on a Python library to interact with StreamPipes. In this way, we would like to unite the power of StreamPipes to easily connect to and read from different data sources, especially in the IoT domain, and the amazing universe of data analytics libraries in Python. </p>"},{"location":"#quickstart","title":"\u26a1\ufe0f Quickstart","text":"<p>As a quick example, we demonstrate how to set up and configure a StreamPipes client. In addition, we will get the available data lake measures out of StreamPipes.</p> <p><pre><code>from streampipes.client import StreamPipesClient\nfrom streampipes.client.config import StreamPipesClientConfig\nfrom streampipes.client.credential_provider import StreamPipesApiKeyCredentials\n\nconfig = StreamPipesClientConfig(\n    credential_provider = StreamPipesApiKeyCredentials(\n        username = \"test@streampipes.apache.org\",\n        api_key = \"DEMO-KEY\",\n        ),\n    host_address = \"localhost\",\n    https_disabled = True,\n    port = 80\n)\n\nclient = StreamPipesClient(client_config=config)\n\n# get all available datat lake measures\nmeasures = client.dataLakeMeasureApi.all()\n\n# get amount of retrieved measures\nlen(measures)\n</code></pre> Output: <pre><code>1\n</code></pre> </p> <pre><code># inspect the data lake measures as pandas dataframe\nmeasures.to_pandas()\n</code></pre> <p>Output: <pre><code>measure_name timestamp_field ... pipeline_is_running num_event_properties\n0 test s0::timestamp ... False 2\n[1 rows x 6 columns]\n</code></pre>  Alternatively, you can provide your credentials via environment variables. Simply define your credential provider as follows:</p> <p><pre><code>from streampipes.client.credential_provider import StreamPipesApiKeyCredentials\n\nStreamPipesApiKeyCredentials()\n</code></pre> This requires to set the following environment variables: <code>SP_API_KEY</code> and <code>SP_USERNAME</code> </p> <p><code>username</code> is always the username that is used to log in into StreamPipes. </p> How to get your StreamPipes API key <p>The <code>api_key</code> can be generated within the UI as demonstrated below: </p> <p></p>"},{"location":"getting-started/developing/","title":"Developing & Contributing","text":""},{"location":"getting-started/developing/#development-guide","title":"\ud83d\udcd6 Development Guide","text":"<p>This document describes how to easily set up your local dev environment to work on StreamPipes Python \ud83d\udc0d. </p>"},{"location":"getting-started/developing/#first-steps","title":"\ud83d\ude80 First Steps","text":"<p>1) Set up your Python environment</p> <p>Create a virtual Python environment using a tool of your choice.  To manage dependencies, we use Poetry, so please install poetry in your local environment, e.g. via <pre><code>pip install poetry\n</code></pre></p> <p>Once poetry is installed you can simply finalize your Python environment by running:</p> <pre><code>poetry install --with dev,stubs  # install everything that is required for the development\npoetry install --with docs  # install everything to work with the documentation\npoetry install --with dev,stubs,docs  # install all optional dependencies related to development\n</code></pre> <p></p> <p>2) Install pre-commit hook</p> <p>The pre-commit hook is run before every commit and takes care about code style, linting, type hints, import sorting, etc. It will stop your commit in case the changes do not apply the expected format. Always check to have the recent version of the pre-commit hook installed otherwise the CI build might fail.  If you are interested, you can have a deeper look on the underlying library: pre-commit.</p> <p><pre><code>pre-commit install\n</code></pre> The definition of the pre-commit hook can be found in .pre-commit-config.yaml.</p> <p></p>"},{"location":"getting-started/developing/#conventions","title":"\ud83d\udc4f Conventions","text":"<p>Below we list some conventions that we have agreed on for creating StreamPipes Python. Please comply to them when you plan to contribute to this project. If you have any other suggestions or would like to discuss them, we would be happy to hear from you on our mailing list dev@streampipes.apache.org or in our discussions on GitHub.</p> <p>1) Use <code>numpy</code> style for Python docstrings \ud83d\udcc4  Please stick to the <code>numpy</code> style when writing docstrings, as we require this for generating our documentation.</p> <p>2) Provide tests \u2705  We are aiming for broad test coverage for the Python package and have therefore set a requirement of at least 90% unit test coverage. Therefore, please remember to write (unit) tests already during development.  If you have problems with writing tests, don't hesitate to ask us for help directly in the PR or even before that via our mailing list (see above).</p> <p>3) Build a similar API as the Java client provides \ud83d\udd04  Whenever possible, please try to develop the API of the Python library the same as the Java client or Java SDK. By doing so, we would like to provide a consistent developer experience and the basis for automated testing in the future.</p>"},{"location":"getting-started/developing/#dependency-management","title":"\ud83d\udce6 Dependency Management","text":"<p>In case you want to add a new dependency to StreamPipes you can use the following command: <pre><code>poetry add &lt;dep-name&gt;\n</code></pre></p> <p>If the dependency is only required for development purpose or the documentation, please stick to one the following: <pre><code>poetry add &lt;dep-name&gt; --group dev\npoetry add &lt;dep-name&gt; --group stubs\npoetry add &lt;dep-name&gt; --group docs\n</code></pre></p> <p>In case you want to regenerate the poetry lock file, e.g., in case you manually updated the <code>pyproject.toml</code>, the following command should be used: <pre><code>poetry lock --no-update\n</code></pre></p> <p>After that, you should install the current version of the poetry lock file to keep your local environment consistent (see command above.)</p>"},{"location":"getting-started/developing/#documentation","title":"\ud83d\udcdaDocumentation","text":"<p>To build our documentation, we use Materials for MkDocs. All files can be found within the <code>docs</code> directory. To pre-view your local version of the documentation, you can use the following command: <pre><code>make livedoc\n</code></pre></p>"},{"location":"getting-started/developing/#roadmap","title":"\ud83d\ude80 Roadmap","text":"<p>Broadly speaking, we plan to expand or add new aspects/functionality to the library where we are focusing on the following:</p> <ul> <li>increase coverage of StreamPipes API \ud83d\udd17</li> <li>build a comprehensive function zoo \ud83d\udc18</li> <li>support more messaging broker \ud83d\udcec</li> <li>possibility to build pipeline elements \ud83d\udd27</li> </ul> <p>In case you want to have a more detailed look on what we are currently planning, have a look at our open issues(more short-term driven).</p> <p>Of course, contributions are always highly appreciated \ud83d\udd2e</p> <p>Stay tuned!</p>"},{"location":"getting-started/developing/#contributing","title":"\ud83d\udc68\u200d\ud83d\udcbb Contributing","text":"<p>Before opening a pull request, review the Get Involved page. It lists information that is required for contributing to StreamPipes.</p> <p>When you contribute code, you affirm that the contribution is your original work and that you license the work to the project under the project's open source license. Whether or not you state this explicitly, by submitting any copyrighted material via pull request, email, or other means you agree to license the material under the project's open source license and warrant that you have the legal authority to do so.</p>"},{"location":"getting-started/first-steps/","title":"First Steps","text":""},{"location":"getting-started/first-steps/#installation","title":"\ud83d\udcda Installation","text":"<p>The StreamPipes Python library is meant to work with Python 3.8 and above. Installation can be done via <code>pip</code>: You can install the latest development version from GitHub, as so:</p> <pre><code>pip install streampipes\n\n# if you want to have the current development state you can also execute\npip install git+https://github.com/apache/streampipes.git#subdirectory=streampipes-client-python\n# the corresponding documentation can be found here: https://streampipes.apache.org/docs/docs/python/dev/\n</code></pre>"},{"location":"getting-started/first-steps/#setting-up-streampipes","title":"\u2b06\ufe0f Setting up StreamPipes","text":"<p>When working with the StreamPipes Python library it is inevitable to have a running StreamPipes instance to connect and interact with. In case you don't have a running instance at hand, you can easily set up one on your local machine. Hereby you need to consider that StreamPipes supports different message broker (e.g., Kafka, NATS). We will demonstrate below how you can easily set up StreamPipes for both supported message brokers. </p>"},{"location":"getting-started/first-steps/#start-streampipes-via-docker-compose","title":"\ud83d\udc33 Start StreamPipes via Docker Compose","text":"<p>The easiest and therefore recommend way to get StreamPipes started is by using docker compose. Therefore, you need Docker running. You can check if Docker is ready on your machine by executing. <pre><code>docker ps\n</code></pre> If this results in an output similar to the following, Docker is ready to continue. <pre><code>CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES\n...            ...       ...       ...       ...       ...       ...\n</code></pre> Otherwise, you need to start docker first. Please read the full guide on how to start StreamPipes with <code>docker compose</code> here.</p>"},{"location":"getting-started/first-steps/#setup-streampipes-with-nats-as-message-broker","title":"Setup StreamPipes with NATS as message broker","text":"<p>The following shows how you can set up a StreamPipes instance that uses NATS as messaging layer. So in this scenario, we will go with <code>docker-compose.nats.yml</code>.  Thereby, when running locally, we need to add the following port mapping entry to <code>services.nats.ports</code>: <pre><code>- 4222:4222\n</code></pre></p> <p>After this modification is applied, StreamPipes can simply be started with this command: <pre><code>docker-compose -f docker-compose.nats.yml up -d\n</code></pre></p> <p>Once all services are started, you can access StreamPipes via <code>http://localhost</code>.</p>"},{"location":"getting-started/first-steps/#setup-streampipes-with-kafka-as-message-broker","title":"Setup StreamPipes with Kafka as message broker","text":"<p>Alternatively, you can use <code>docker-compose.yml</code> to start StreamPipes with Kafka as messaging layer. When running locally we have to modify <code>services.kafka.environment</code> and add the ports to <code>services.kafka.ports</code>: <pre><code>environment:\nKAFKA_LISTENER_SECURITY_PROTOCOL_MAP: PLAINTEXT:PLAINTEXT,OUTSIDE:PLAINTEXT\nKAFKA_ADVERTISED_LISTENERS: PLAINTEXT://:9092,OUTSIDE://localhost:9094\nKAFKA_LISTENERS: PLAINTEXT://:9092,OUTSIDE://:9094\n...\nports:\n- 9094:9094\n</code></pre> Then, you need to execute the following command: <pre><code>docker-compose -f docker-compose.yml up -d\n</code></pre></p> <p>Once all services are started, you can access StreamPipes via <code>http://localhost</code>.</p> <p>In case you want to have more control over your StreamPipes setup, you might take a look at our deployment CLI.</p> <p>Have fun discovering StreamPipes and our Python library \ud83d\ude80</p>"},{"location":"getting-started/quickstart/","title":"Quickstart","text":""},{"location":"getting-started/quickstart/#quickstart","title":"\u26a1\ufe0f Quickstart","text":"<p>As a quick example, we demonstrate how to set up and configure a StreamPipes client. In addition, we will get the available data lake measures out of StreamPipes.</p> <p><pre><code>from streampipes.client import StreamPipesClient\nfrom streampipes.client.config import StreamPipesClientConfig\nfrom streampipes.client.credential_provider import StreamPipesApiKeyCredentials\n\nconfig = StreamPipesClientConfig(\n    credential_provider = StreamPipesApiKeyCredentials(\n        username = \"test@streampipes.apache.org\",\n        api_key = \"DEMO-KEY\",\n        ),\n    host_address = \"localhost\",\n    https_disabled = True,\n    port = 80\n)\n\nclient = StreamPipesClient(client_config=config)\n\n# get all available datat lake measures\nmeasures = client.dataLakeMeasureApi.all()\n\n# get amount of retrieved measures\nlen(measures)\n</code></pre> Output: <pre><code>1\n</code></pre> </p> <pre><code># inspect the data lake measures as pandas dataframe\nmeasures.to_pandas()\n</code></pre> <p>Output: <pre><code>measure_name timestamp_field ... pipeline_is_running num_event_properties\n0 test s0::timestamp ... False 2\n[1 rows x 6 columns]\n</code></pre>  Alternatively, you can provide your credentials via environment variables. Simply define your credential provider as follows:</p> <p><pre><code>from streampipes.client.credential_provider import StreamPipesApiKeyCredentials\n\nStreamPipesApiKeyCredentials()\n</code></pre> This requires to set the following environment variables: <code>SP_API_KEY</code> and <code>SP_USERNAME</code> </p> <p><code>username</code> is always the username that is used to log in into StreamPipes.  The <code>api_key</code> can be generated within the UI as demonstrated below:</p> <p></p>"},{"location":"reference/client/client/","title":"Client","text":"<p>Implementation of the StreamPipes client. The client is designed as the central point of interaction with the StreamPipes API and provides all functionalities to communicate with the API.</p>"},{"location":"reference/client/client/#streampipes.client.client.StreamPipesClient","title":"<code>StreamPipesClient(client_config, logging_level=logging.INFO)</code>","text":"<p>The client to connect to StreamPipes.</p> <p>This is the central point of contact with StreamPipes and provides all the functionalities to interact with it.</p> <p>The client provides so-called \"endpoints\" each of which refers to an endpoint of the StreamPipes API, e.g. <code>.dataLakeMeasureApi</code>. An endpoint provides the actual methods to interact with StreamPipes API.</p> PARAMETER  DESCRIPTION <code>client_config</code> <p>Configures the client to connect properly to the StreamPipes instance.</p> <p> TYPE: <code>StreamPipesClientConfig</code> </p> <code>logging_level</code> <p>Influences the log messages emitted by the <code>StreamPipesClient</code></p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>INFO</code> </p> ATTRIBUTE DESCRIPTION <code>dataLakeMeasureApi</code> <p>Instance of the data lake measure endpoint</p> <p> TYPE: <code>DataLakeMeasureEndpoint</code> </p> <code>dataStreamApi</code> <p>Instance of the data stream endpoint</p> <p> TYPE: <code>DataStreamEndpoint</code> </p> RAISES DESCRIPTION <code>AttributeError:</code> <p>In case an invalid configuration of the <code>StreamPipesClientConfig</code> is passed</p> <p>Examples:</p> <pre><code>from streampipes.client import StreamPipesClient\nfrom streampipes.client.config import StreamPipesClientConfig\nfrom streampipes.client.credential_provider import StreamPipesApiKeyCredentials\n</code></pre> <pre><code>client_config = StreamPipesClientConfig(\n    credential_provider=StreamPipesApiKeyCredentials(\n         username=\"test-user\",\n         api_key=\"api-key\"\n     ),\n     host_address=\"localhost\",\n     https_disabled=True\n)\n</code></pre> <p>The following way of instantiating a client instance is intended to be consistent with the StreamPipes Java client. <pre><code>client = StreamPipesClient.create(client_config=client_config)\n</code></pre></p> <p>If you prefer a more pythonic way, you can simply write: <pre><code>client = StreamPipesClient(client_config=client_config)\n</code></pre></p> <p>To interact with an endpoint: <pre><code>data_lake_measures = client.dataLakeMeasureApi.all()\n</code></pre></p> <p>To inspect returned data as a pandas dataframe: <pre><code>data_lake_measures.to_pandas()\n#\n#     measure_name timestamp_field  ... pipeline_is_running num_event_properties\n# 0           test   s0::timestamp  ...               False                    2\n# [1 rows x 6 columns]\n</code></pre></p>"},{"location":"reference/client/client/#streampipes.client.client.StreamPipesClient.base_api_path","title":"<code>base_api_path: str</code>  <code>property</code>","text":"<p>Constructs the basic API URL from the given <code>client_config</code>.</p> RETURNS DESCRIPTION <code>base_api_path</code> <p>basic API path of the connected StreamPipes instance</p> <p> TYPE: <code>str</code> </p>"},{"location":"reference/client/client/#streampipes.client.client.StreamPipesClient.http_headers","title":"<code>http_headers: Dict[str, str]</code>  <code>property</code>","text":"<p>Returns the HTTP headers used for all requests.</p> <p>The HTTP headers are composed of the authentication headers supplied by the credential provider and additional required headers (currently this is only the application header).</p> RETURNS DESCRIPTION <code>http_headers</code> <p>header information for HTTP requests as string key-value pairs.</p> <p> TYPE: <code>Dict[str, str]</code> </p>"},{"location":"reference/client/client/#streampipes.client.client.StreamPipesClient.create","title":"<code>create(client_config, logging_level=logging.INFO)</code>  <code>classmethod</code>","text":"<p>Returns an instance of the <code>StreamPipesPythonClient</code>.</p> <p>Provides consistency to the StreamPipes Java client.</p> PARAMETER  DESCRIPTION <code>client_config</code> <p>Configures the client to connect properly to the StreamPipes instance.</p> <p> TYPE: <code>StreamPipesClientConfig</code> </p> <code>logging_level</code> <p>Influences the log messages emitted by the <code>StreamPipesClient</code>.</p> <p> TYPE: <code>int</code> DEFAULT: <code>INFO</code> </p> RETURNS DESCRIPTION <code>StreamPipesClient</code>"},{"location":"reference/client/client/#streampipes.client.client.StreamPipesClient.describe","title":"<code>describe()</code>","text":"<p>Prints a short description of the connected StreamPipes instance and the available resources to the console.</p> RETURNS DESCRIPTION <code>    None</code> <p>Examples:</p> <p><pre><code>client.describe()\n</code></pre> Output: <pre><code>Hi there!\nYou are connected to a StreamPipes instance running at http://localhost:80.\nThe following StreamPipes resources are available with this client:\n6x DataStreams\n1x DataLakeMeasures\n</code></pre></p>"},{"location":"reference/client/config/","title":"Config","text":"<p>Configuration class for the StreamPipes client.</p>"},{"location":"reference/client/config/#streampipes.client.config.StreamPipesClientConfig","title":"<code>StreamPipesClientConfig(credential_provider, host_address, https_disabled=False, port=80)</code>  <code>dataclass</code>","text":"<p>Configure the StreamPipes client in accordance to the actual StreamPipes instance to connect to.</p> <p>An instance is provided to the <code>StreamPipesClient</code> to configure it properly.</p> PARAMETER  DESCRIPTION <code>credential_provider</code> <p>Provides the credentials to authenticate with the StreamPipes API.</p> <p> TYPE: <code>CredentialProvider</code> </p> <code>host_address</code> <p>Host address of the StreamPipes instance to connect to. Should be provided without the protocol/scheme, e.g. as <code>localhost</code> or <code>streampipes.xyz</code>.</p> <p> TYPE: <code>str</code> </p> <code>https_disabled</code> <p>Determines whether https is used to connect to StreamPipes.</p> <p> TYPE: <code>Optional[bool]</code> DEFAULT: <code>False</code> </p> <code>port</code> <p>Specifies the port under which the StreamPipes API is available, e.g., <code>80</code> (with http) or <code>443</code> (with https)</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>80</code> </p> <p>Examples:</p> <p>see StreamPipesClient</p>"},{"location":"reference/client/credential_provider/","title":"Credential provider","text":"<p>Implementation of credential providers. A credential provider supplies the specified sort of credentials in the appropriate HTTP header format. The headers are then used by the client to connect to StreamPipes.</p>"},{"location":"reference/client/credential_provider/#streampipes.client.credential_provider.CredentialProvider","title":"<code>CredentialProvider</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Abstract implementation of a credential provider. Must be inherited by all credential providers.</p>"},{"location":"reference/client/credential_provider/#streampipes.client.credential_provider.CredentialProvider.make_headers","title":"<code>make_headers(http_headers=None)</code>","text":"<p>Creates the HTTP headers for the specific credential provider.</p> <p>Concrete authentication headers must be defined in the implementation of a credential provider.</p> PARAMETER  DESCRIPTION <code>http_headers</code> <p>Additional HTTP headers the generated headers are extended by.</p> <p> TYPE: <code>Optional[Dict[str, str]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>https_headers</code> <p>Dictionary with header information as string key-value pairs.  Contains all pairs given as parameter plus the header pairs for authentication determined by the credential provider.</p> <p> TYPE: <code>Dict[str, str]</code> </p>"},{"location":"reference/client/credential_provider/#streampipes.client.credential_provider.StreamPipesApiKeyCredentials","title":"<code>StreamPipesApiKeyCredentials(username=None, api_key=None)</code>","text":"<p>             Bases: <code>CredentialProvider</code></p> <p>A credential provider that allows authentication via a StreamPipes API Token.</p> <p>The required token can be generated via the StreamPipes UI (see the description on our start-page.</p> <p>Both parameters can either be passed as arguments or remain unset. If they are not passed, they are retrieved from environment variables:</p> <ul> <li><code>SP_USERNAME</code> is expected to contain the username</li> <li><code>SP_API_KEY</code> is expected to contain the API key</li> </ul> PARAMETER  DESCRIPTION <code>username</code> <p>The username to which the API token is granted, e.g., <code>demo-user@streampipes.apche.org</code>. If not passed, the username is retrieved from environment variable <code>SP_USERNAME</code>.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>api_key</code> <p>The StreamPipes API key as it is displayed in the UI. If not passed, the api key is retrieved from environment variable <code>SP_API_KEY</code></p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <p>Examples:</p> <p>see StreamPipesClient</p>"},{"location":"reference/client/credential_provider/#streampipes.client.credential_provider.StreamPipesApiKeyCredentials.from_env","title":"<code>from_env(username_env, api_key_env)</code>  <code>classmethod</code>","text":"<p>DEPRECATED - use the class constructor instead</p> <p>Returns an api key provider parameterized via environment variables.</p> PARAMETER  DESCRIPTION <code>username_env</code> <p>Name of the environment variable that contains the username</p> <p> TYPE: <code>str</code> </p> <code>api_key_env</code> <p>Name of the environment variable that contains the API key</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>StreamPipesApiKeyCredentials</code> RAISES DESCRIPTION <code>KeyError</code> <p>If one of the environment variables is not defined</p>"},{"location":"reference/endpoint/endpoint/","title":"Endpoint","text":"<p>General implementation for an endpoint. Provided classes and assets are aimed to be used for developing endpoints. An endpoint provides all options to communicate with ad dedicated part of StreamPipes in a handy way.</p>"},{"location":"reference/endpoint/endpoint/#streampipes.endpoint.endpoint.APIEndpoint","title":"<code>APIEndpoint(parent_client)</code>","text":"<p>             Bases: <code>Endpoint</code></p> <p>Abstract implementation of an API endpoint.</p> <p>Serves as template for all endpoints of the StreamPipes API. By design, endpoints are only instantiated within the <code>__init__</code> method of the StreamPipesClient.</p>"},{"location":"reference/endpoint/endpoint/#streampipes.endpoint.endpoint.APIEndpoint.all","title":"<code>all()</code>","text":"<p>Get all resources of this endpoint provided by the StreamPipes API.</p> <p>Results are provided as an instance of a <code>ResourceContainer</code> that allows to handle the returned resources in a comfortable and pythonic way.</p> RETURNS DESCRIPTION <code>container</code> <p>container element that bundles the returned resources</p> <p> TYPE: <code>ResourceContainer</code> </p>"},{"location":"reference/endpoint/endpoint/#streampipes.endpoint.endpoint.APIEndpoint.build_url","title":"<code>build_url()</code>","text":"<p>Builds the endpoint's URL of the API path.</p> RETURNS DESCRIPTION <code>url</code> <p>The URL of the endpoint</p> <p> TYPE: <code>str</code> </p>"},{"location":"reference/endpoint/endpoint/#streampipes.endpoint.endpoint.APIEndpoint.get","title":"<code>get(identifier, **kwargs)</code>","text":"<p>Queries the specified resource from the API endpoint.</p> PARAMETER  DESCRIPTION <code>identifier</code> <p>The identifier of the resource to be queried.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>resource</code> <p>The specified resource as an instance of the corresponding model class.</p> <p> TYPE: <code>Resource</code> </p>"},{"location":"reference/endpoint/endpoint/#streampipes.endpoint.endpoint.APIEndpoint.post","title":"<code>post(resource)</code>","text":"<p>Allows to post a resource to the StreamPipes API.</p> PARAMETER  DESCRIPTION <code>resource</code> <p>The resource to be posted.</p> <p> TYPE: <code>Resource</code> </p> RETURNS DESCRIPTION <code>None</code>"},{"location":"reference/endpoint/endpoint/#streampipes.endpoint.endpoint.Endpoint","title":"<code>Endpoint(parent_client)</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Abstract implementation of a StreamPipes endpoint.</p> <p>Serves as template for all endpoints used for interaction with a StreamPipes instance. By design, endpoints are only instantiated within the <code>__init__</code> method of the StreamPipesClient.</p> PARAMETER  DESCRIPTION <code>parent_client</code> <p>This parameter expects the instance of <code>StreamPipesClient</code> the endpoint is attached to.</p> <p> TYPE: <code>StreamPipesClient</code> </p>"},{"location":"reference/endpoint/endpoint/#streampipes.endpoint.endpoint.MessagingEndpoint","title":"<code>MessagingEndpoint(parent_client)</code>","text":"<p>             Bases: <code>Endpoint</code></p> <p>Abstract implementation of a StreamPipes messaging endpoint.</p> <p>Serves as template for all endpoints used for interacting with the StreamPipes messaging layer directly. Therefore, they need to provide the functionality to talk with the broker system running in StreamPipes. By design, endpoints are only instantiated within the <code>__init__</code> method of the StreamPipesClient.</p>"},{"location":"reference/endpoint/endpoint/#streampipes.endpoint.endpoint.MessagingEndpoint.broker","title":"<code>broker: Broker</code>  <code>property</code> <code>writable</code>","text":"<p>Defines the broker instance that is used to connect to StreamPipes' messaging layer.</p> <p>This instance enables the client to authenticate to the broker used in the target StreamPipes instance, to consume messages from and to write messages to the broker.</p> RAISES DESCRIPTION <code>MessagingEndpointNotConfiguredError</code> <p>If the endpoint is used before the broker instance is set via <code>configure()</code></p> RETURNS DESCRIPTION <code>broker</code> <p>The broker instance to be used to communicate with StreamPipes' messaging layer.</p> <p> TYPE: <code>Broker</code> </p>"},{"location":"reference/endpoint/endpoint/#streampipes.endpoint.endpoint.MessagingEndpoint.configure","title":"<code>configure(broker)</code>","text":"<p>Configures the message endpoint by setting the broker instance to be used.</p> <p>This configuration step is required before the endpoint can be actually used. The based <code>broker</code> instance is passed to an internal property</p> PARAMETER  DESCRIPTION <code>broker</code> <p>Broker instance that should be used for this endpoint</p> <p> TYPE: <code>Broker</code> </p> RETURNS DESCRIPTION <code>None</code>"},{"location":"reference/endpoint/exceptions/","title":"Exceptions","text":"<p>Custom exceptions dedicated for the endpoints module</p>"},{"location":"reference/endpoint/exceptions/#streampipes.endpoint.exceptions.MessagingEndpointNotConfiguredError","title":"<code>MessagingEndpointNotConfiguredError(endpoint_name)</code>","text":"<p>             Bases: <code>Exception</code></p> <p>Exception that indicates that an instance of a messaging endpoint has not been configured.</p> <p>This error occurs when an instance of a messaging endpoint is used before the broker instance to be used is configured by passing it to the <code>configure()</code> method.</p> PARAMETER  DESCRIPTION <code>endpoint_name</code> <p>The name of the endpoint that caused the error</p> <p> TYPE: <code>str</code> </p>"},{"location":"reference/endpoint/api/data_lake_measure/","title":"Data lake measure","text":"<p>Specific implementation of the StreamPipes API's data lake measure endpoints. This endpoint allows to consume data stored in StreamPipes' data lake.</p>"},{"location":"reference/endpoint/api/data_lake_measure/#streampipes.endpoint.api.data_lake_measure.DataLakeMeasureEndpoint","title":"<code>DataLakeMeasureEndpoint(parent_client)</code>","text":"<p>             Bases: <code>APIEndpoint</code></p> <p>Implementation of the DataLakeMeasure endpoint.</p> <p>This endpoint provides an interface to all data stored in the StreamPipes data lake.</p> <p>Consequently, it allows querying metadata about available data sets (see <code>all()</code> method). The metadata is returned as an instance of <code>DataLakeMeasures</code>.</p> <p>In addition, the endpoint provides direct access to the data stored in the data laka by querying a specific data lake measure using the <code>get()</code> method.</p> <p>Examples:</p> <pre><code>from streampipes.client import StreamPipesClient\nfrom streampipes.client.config import StreamPipesClientConfig\nfrom streampipes.client.credential_provider import StreamPipesApiKeyCredentials\n</code></pre> <pre><code>client_config = StreamPipesClientConfig(\n    credential_provider=StreamPipesApiKeyCredentials(username=\"test-user\", api_key=\"api-key\"),\n    host_address=\"localhost\",\n    port=8082,\n    https_disabled=True\n)\nclient = StreamPipesClient.create(client_config=client_config)\n</code></pre> <p><pre><code># get all existing data lake measures from StreamPipes\ndata_lake_measures = client.dataLakeMeasureApi.all()\n\n# let's take a look how many we got\nlen(data_lake_measures)\n</code></pre> <pre><code>5\n</code></pre></p> <p><pre><code># Retrieve a specific data lake measure as a pandas DataFrame\nflow_rate_pd = client.dataLakeMeasureApi.get(identifier=\"flow-rate\").to_pandas()\nflow_rate_pd\n</code></pre> <pre><code>                         time    density  mass_flow    sensorId  sensor_fault_flags  temperature  volume_flow\n0    2023-02-24T16:19:41.472Z  50.872730   3.309556  flowrate02               False    44.448483     5.793138\n1    2023-02-24T16:19:41.482Z  47.186588   5.608580  flowrate02               False    40.322033     0.058015\n2    2023-02-24T16:19:41.493Z  46.735321   7.692881  flowrate02               False    49.239639    10.283526\n3    2023-02-24T16:19:41.503Z  40.169796   3.632898  flowrate02               False    49.933754     6.893441\n4    2023-02-24T16:19:41.513Z  49.635124   0.711260  flowrate02               False    50.106617     2.999871\n..                        ...        ...        ...         ...                 ...          ...          ...\n995  2023-02-24T16:19:52.927Z  50.057495   1.740114  flowrate02               False    46.558231     1.818237\n996  2023-02-24T16:19:52.94Z   41.038895   7.211723  flowrate02               False    48.048622     2.127493\n997  2023-02-24T16:19:52.952Z  45.837013   7.770180  flowrate02               False    48.188026     7.892062\n998  2023-02-24T16:19:52.965Z  43.389065   4.458602  flowrate02               False    48.280899     5.733892\n999  2023-02-24T16:19:52.977Z  44.056030   2.592060  flowrate02               False    47.505951     4.260697\n</code></pre></p> <p>As you can see, the returned amount of rows per default is <code>1000</code>. We can modify this behavior by passing the <code>limit</code> paramter. <pre><code>flow_rate_pd = client.dataLakeMeasureApi.get(identifier=\"flow-rate\", limit=10).to_pandas()\nlen(flow_rate_pd)\n</code></pre> <pre><code>10\n</code></pre></p> <p>If we are only interested in the values for <code>density</code>, <code>columns</code> allows us to select the columns to be returned: <pre><code>flow_rate_pd = client.dataLakeMeasureApi.get(identifier=\"flow-rate\", columns='density', limit=3).to_pandas()\nflow_rate_pd\n</code></pre> <pre><code>                       time    density\n0  2023-02-24T16:19:41.472Z  50.872730\n1  2023-02-24T16:19:41.482Z  47.186588\n2  2023-02-24T16:19:41.493Z  46.735321\n</code></pre></p> <p>This is only a subset of the available query parameters, find them at MeasurementGetQueryConfig.</p>"},{"location":"reference/endpoint/api/data_lake_measure/#streampipes.endpoint.api.data_lake_measure.DataLakeMeasureEndpoint.get","title":"<code>get(identifier, **kwargs)</code>","text":"<p>Queries the specified data lake measure from the API.</p> <p>By default, the maximum number of returned records is 1000. This behaviour can be influenced by passing the parameter <code>limit</code> with a different value (see MeasurementGetQueryConfig).</p> PARAMETER  DESCRIPTION <code>identifier</code> <p>The identifier of the data lake measure to be queried.</p> <p> TYPE: <code>str</code> </p> <code>**kwargs</code> <p>keyword arguments can be used to provide additional query parameters. The available query parameters are defined by the MeasurementGetQueryConfig.</p> <p> TYPE: <code>Optional[Dict[str, Any]]</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>measurement</code> <p>the specified data lake measure</p> <p> TYPE: <code>DataLakeMeasures</code> </p> <p>Examples:</p> <p>see directly at DataLakeMeasureEndpoint.</p>"},{"location":"reference/endpoint/api/data_lake_measure/#streampipes.endpoint.api.data_lake_measure.MeasurementGetQueryConfig","title":"<code>MeasurementGetQueryConfig</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Config class describing the parameters of the <code>get()</code> method for measurements.</p> <p>This config class is used to validate the provided query parameters for the GET endpoint of measurements. Additionally, it takes care of the conversion to a proper HTTP query string. Thereby, parameter names are adapted to the naming of the StreamPipes API, for which Pydantic aliases are used.</p> ATTRIBUTE DESCRIPTION <code>columns</code> <p>A comma separated list of column names (e.g., <code>time,value</code>) If provided, the returned data only consists of the given columns. Please be aware that the column <code>time</code> as an index is always included.</p> <p> TYPE: <code>Optional[List[str]]</code> </p> <code>end_date</code> <p>Restricts queried data to be younger than the specified time.</p> <p> TYPE: <code>Optional[datetime]</code> </p> <code>limit</code> <p>Amount of records returned at maximum (default: <code>1000</code>)  This needs to be at least <code>1</code></p> <p> TYPE: <code>Optional[int]</code> </p> <code>offset</code> <p>Offset to be applied to returned data  This needs to be at least <code>0</code></p> <p> TYPE: <code>Optional[int]</code> </p> <code>order</code> <p>Ordering of query results  Allowed values: <code>ASC</code> and <code>DESC</code> (default: <code>ASC</code>)</p> <p> TYPE: <code>Optional[str]</code> </p> <code>page_no</code> <p>Page number used for paging operation  This needs to be at least <code>1</code></p> <p> TYPE: <code>Optional[int]</code> </p> <code>start_date</code> <p>Restricts queried data to be older than the specified time</p> <p> TYPE: <code>Optional[datetime]</code> </p>"},{"location":"reference/endpoint/api/data_lake_measure/#streampipes.endpoint.api.data_lake_measure.MeasurementGetQueryConfig.Config","title":"<code>Config</code>","text":"<p>Pydantic Config class</p>"},{"location":"reference/endpoint/api/data_lake_measure/#streampipes.endpoint.api.data_lake_measure.MeasurementGetQueryConfig.build_query_string","title":"<code>build_query_string()</code>","text":"<p>Builds a HTTP query string for the config.</p> <p>This method returns an HTTP query string for the invoking config. It follows the following structure <code>?param1=value1&amp;param2=value2...</code>. This query string is not an entire URL, instead it needs to appended to an API path.</p> RETURNS DESCRIPTION <code>query_param_string</code> <p>HTTP query params string (<code>?param1=value1&amp;param2=value2...</code>)</p> <p> TYPE: <code>str</code> </p>"},{"location":"reference/endpoint/api/data_lake_measure/#streampipes.endpoint.api.data_lake_measure.StreamPipesQueryValidationError","title":"<code>StreamPipesQueryValidationError</code>","text":"<p>             Bases: <code>Exception</code></p> <p>A custom exception to be raised when the validation of query parameter causes an error.</p>"},{"location":"reference/endpoint/api/data_stream/","title":"Data stream","text":"<p>Specific implementation of the StreamPipes API's data stream endpoints.</p>"},{"location":"reference/endpoint/api/data_stream/#streampipes.endpoint.api.data_stream.DataStreamEndpoint","title":"<code>DataStreamEndpoint(parent_client)</code>","text":"<p>             Bases: <code>APIEndpoint</code></p> <p>Implementation of the DataStream endpoint.</p> <p>Consequently, it allows querying metadata about available data streams (see <code>all()</code> method). The metadata is returned as an instance of <code>DataStreams</code>.</p> <p>Examples:</p> <pre><code>from streampipes.client import StreamPipesClient\nfrom streampipes.client.config import StreamPipesClientConfig\nfrom streampipes.client.credential_provider import StreamPipesApiKeyCredentials\n\nclient_config = StreamPipesClientConfig(\n    credential_provider=StreamPipesApiKeyCredentials(username=\"test-user\", api_key=\"api-key\"),\n    host_address=\"localhost\",\n    port=8082,\n    https_disabled=True\n)\nclient = StreamPipesClient.create(client_config=client_config)\n</code></pre> <p><pre><code># let's get all existing data streams in StreamPipes\ndata_streams = client.dataStreamApi.all()\nlen(data_streams)\n</code></pre> <pre><code>2\n</code></pre></p>"},{"location":"reference/endpoint/api/version/","title":"Version","text":"<p>Specific implementation of the StreamPipes API's version endpoint.</p>"},{"location":"reference/endpoint/api/version/#streampipes.endpoint.api.version.VersionEndpoint","title":"<code>VersionEndpoint(parent_client)</code>","text":"<p>             Bases: <code>APIEndpoint</code></p> <p>Implementation of the Versions endpoint.</p> <p>This endpoint provides metadata about the StreamPipes version of the connected instance. It only allows to apply the <code>get()</code> method with an empty string as identifier.</p> PARAMETER  DESCRIPTION <code>parent_client</code> <p>The instance of StreamPipesClient the endpoint is attached to.</p> <p> TYPE: <code>StreamPipesClient</code> </p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from streampipes.client import StreamPipesClient\n&gt;&gt;&gt; from streampipes.client.config import StreamPipesClientConfig\n&gt;&gt;&gt; from streampipes.client.credential_provider import StreamPipesApiKeyCredentials\n</code></pre> <pre><code>&gt;&gt;&gt; client_config = StreamPipesClientConfig(\n...     credential_provider=StreamPipesApiKeyCredentials(username=\"test-user\", api_key=\"api-key\"),\n...     host_address=\"localhost\",\n...     port=8082,\n...     https_disabled=True\n... )\n</code></pre> <pre><code>&gt;&gt;&gt; client = StreamPipesClient.create(client_config=client_config)\n</code></pre> <pre><code>&gt;&gt;&gt; client.versionApi.get(identifier=\"\").to_dict(use_source_names=False)\n{'backend_version': '0.95.0'}\n</code></pre>"},{"location":"reference/endpoint/api/version/#streampipes.endpoint.api.version.VersionEndpoint.all","title":"<code>all()</code>","text":"<p>Usually, this method returns information about all resources provided by this endpoint. However, this endpoint does not support this kind of operation.</p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>this endpoint does not return multiple entries, therefore this method is not available</p>"},{"location":"reference/endpoint/api/version/#streampipes.endpoint.api.version.VersionEndpoint.get","title":"<code>get(identifier, **kwargs)</code>","text":"<p>Queries the resource from the API endpoint.</p> <p>For this endpoint only one resource is available.</p> PARAMETER  DESCRIPTION <code>identifier</code> <p>Not supported by this endpoint, is set to an empty string.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>versions</code> <p>The specified resource as an instance of the corresponding model class(Version).  # noqa: 501</p> <p> TYPE: <code>Version</code> </p>"},{"location":"reference/endpoint/api/version/#streampipes.endpoint.api.version.VersionEndpoint.post","title":"<code>post(resource)</code>","text":"<p>Usually, this method allows to create via this endpoint. Since the data represented by this endpoint is immutable, it does not support this kind of operation.</p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>this endpoint does not allow for POST requests, therefore this method is not available</p>"},{"location":"reference/function_zoo/river_function/","title":"River function","text":""},{"location":"reference/function_zoo/river_function/#streampipes.function_zoo.river_function.OnlineML","title":"<code>OnlineML(client, stream_ids, model, prediction_type=RuntimeType.STRING.value, supervised=False, target_label=None, on_start=lambda self, context: None, on_event=lambda self, event, streamId: None, on_stop=lambda self: None)</code>","text":"<p>Wrapper class to enable an easy usage for Online Machine Learning models of the River library.</p> <p>It creates a StreamPipesFunction to train a model with the incoming events of a data stream and creates an output data stream that publishes the prediction to StreamPipes.</p> PARAMETER  DESCRIPTION <code>client</code> <p>The client for the StreamPipes API.</p> <p> TYPE: <code>StreamPipesClient</code> </p> <code>stream_ids</code> <p>The ids of the data stream to train the model.</p> <p> TYPE: <code>List[str]</code> </p> <code>model</code> <p>The model to train. It meant to be a River model/pipeline, but can be every model with a 'learn_one' and 'predict_one' methode.</p> <p> TYPE: <code>Any</code> </p> <code>prediction_type</code> <p>The data type of the prediction. Is only needed when you continue to work with the prediction in StreamPipes.</p> <p> TYPE: <code>str</code> DEFAULT: <code>value</code> </p> <code>supervised</code> <p>Define if the model is supervised or unsupervised.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>target_label</code> <p>Define the name of the target attribute if the model is supervised.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>on_start</code> <p>A function to be called when this StreamPipesFunction gets started.</p> <p> TYPE: <code>Callable[[Any, FunctionContext], None]</code> DEFAULT: <code>lambda self, context: None</code> </p> <code>on_event</code> <p>A function to be called when this StreamPipesFunction receives an event.</p> <p> TYPE: <code>Callable[[Any, Dict[str, Any], str], None]</code> DEFAULT: <code>lambda self, event, streamId: None</code> </p> <code>on_stop</code> <p>A function to be called when this StreamPipesFunction gets stopped.</p> <p> TYPE: <code>Callable[[Any], None]</code> DEFAULT: <code>lambda self: None</code> </p>"},{"location":"reference/function_zoo/river_function/#streampipes.function_zoo.river_function.OnlineML.set_learning","title":"<code>set_learning(learning)</code>","text":"<p>Start or stop the training of the model.</p> PARAMETER  DESCRIPTION <code>learning</code> <p>Defines if the training should be continued</p> <p> TYPE: <code>bool</code> </p>"},{"location":"reference/function_zoo/river_function/#streampipes.function_zoo.river_function.OnlineML.start","title":"<code>start()</code>","text":"<p>Registers the function and starts the training.</p>"},{"location":"reference/function_zoo/river_function/#streampipes.function_zoo.river_function.OnlineML.stop","title":"<code>stop()</code>","text":"<p>Stops the function and ends the training forever.</p>"},{"location":"reference/function_zoo/river_function/#streampipes.function_zoo.river_function.RiverFunction","title":"<code>RiverFunction(function_definition, model, supervised, target_label, on_start, on_event, on_stop)</code>","text":"<p>             Bases: <code>StreamPipesFunction</code></p> <p>Implementation of a StreamPipesFunction to enable an easy usage for Online Machine Learning models of the River library.</p> <p>The function trains the model with the incoming events and publishes the prediction to an output data stream.</p> PARAMETER  DESCRIPTION <code>function_definition</code> <p>The function definition which contains the output stream.</p> <p> TYPE: <code>FunctionDefinition</code> </p> <code>model</code> <p>The model to train. It meant to be a River model/pipeline, but can be every model with a 'learn_one' and 'predict_one' method.</p> <p> TYPE: <code>Any</code> </p> <code>supervised</code> <p>Define if the model is supervised or unsupervised.</p> <p> TYPE: <code>bool</code> </p> <code>target_label</code> <p>Define the name of the target attribute if the model is supervised.</p> <p> TYPE: <code>Optional[str]</code> </p> <code>on_start</code> <p>A function to be called when this StreamPipesFunction gets started.</p> <p> TYPE: <code>Callable[[Any, FunctionContext], None]</code> </p> <code>on_event</code> <p>A function to be called when this StreamPipesFunction receives an event.</p> <p> TYPE: <code>Callable[[Any, Dict[str, Any], str], None]</code> </p> <code>on_stop</code> <p>A function to be called when this StreamPipesFunction gets stopped.</p> <p> TYPE: <code>Callable[[Any], None]</code> </p>"},{"location":"reference/function_zoo/river_function/#streampipes.function_zoo.river_function.RiverFunction.onEvent","title":"<code>onEvent(event, streamId)</code>","text":"<p>Trains the model with the incoming events and sends the prediction back to StreamPipes.</p> PARAMETER  DESCRIPTION <code>event</code> <p>The incoming event that serves as input for the function</p> <p> TYPE: <code>Dict[str, Any]</code> </p> <code>streamId</code> <p>Identifier of the corresponding data stream</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>None</code>"},{"location":"reference/function_zoo/river_function/#streampipes.function_zoo.river_function.RiverFunction.onServiceStarted","title":"<code>onServiceStarted(context)</code>","text":"<p>Executes the <code>on_start</code> method of the function.</p> PARAMETER  DESCRIPTION <code>context</code> <p>The functions' context</p> <p> TYPE: <code>FunctionContext</code> </p> RETURNS DESCRIPTION <code>None</code>"},{"location":"reference/function_zoo/river_function/#streampipes.function_zoo.river_function.RiverFunction.onServiceStopped","title":"<code>onServiceStopped()</code>","text":"<p>Executes the <code>on_stop</code> function.</p>"},{"location":"reference/functions/function_handler/","title":"Function handler","text":""},{"location":"reference/functions/function_handler/#streampipes.functions.function_handler.FunctionHandler","title":"<code>FunctionHandler(registration, client)</code>","text":"<p>The function handler manages the StreamPipes Functions.</p> <p>It controls the connection to the brokers, starts the functions, manages the broadcast of the live data and is able to stop the connection to the brokers and functions.</p> PARAMETER  DESCRIPTION <code>registration</code> <p>The registration, that contains the StreamPipesFunctions.</p> <p> TYPE: <code>Registration</code> </p> <code>client</code> <p>The client to interact with the API.</p> <p> TYPE: <code>StreamPipesClient</code> </p> ATTRIBUTE DESCRIPTION <code>stream_contexts</code> <p>Map of all data stream contexts</p> <p> TYPE: <code>Dict[str, DataStreamContext]</code> </p> <code>brokers</code> <p>List of all registered brokers</p> <p> TYPE: <code>List[Broker]</code> </p>"},{"location":"reference/functions/function_handler/#streampipes.functions.function_handler.FunctionHandler.disconnect","title":"<code>disconnect()</code>","text":"<p>Disconnects from the brokers and stops all functions.</p> RETURNS DESCRIPTION <code>None</code>"},{"location":"reference/functions/function_handler/#streampipes.functions.function_handler.FunctionHandler.force_stop_functions","title":"<code>force_stop_functions()</code>","text":"<p>Stops the StreamPipesFunctions when the event loop was stopped without stopping the functions.</p> RETURNS DESCRIPTION <code>None</code> WARNS DESCRIPTION <code>UserWarning</code> <p>If there is a running event loop and the functions should be stopped by disconnecting from the broker.</p>"},{"location":"reference/functions/function_handler/#streampipes.functions.function_handler.FunctionHandler.initializeFunctions","title":"<code>initializeFunctions()</code>","text":"<p>Creates the context for every data stream and starts the event loop to manage the StreamPipes Functions.</p> RETURNS DESCRIPTION <code>None</code>"},{"location":"reference/functions/registration/","title":"Registration","text":""},{"location":"reference/functions/registration/#streampipes.functions.registration.Registration","title":"<code>Registration()</code>","text":"<p>Manages the existing StreamPipesFunctions and registers them.</p> ATTRIBUTE DESCRIPTION <code>functions</code> <p>List of all registered StreamPipesFunction</p> <p> TYPE: <code>List[StreamPipesFunction]</code> </p>"},{"location":"reference/functions/registration/#streampipes.functions.registration.Registration.getFunctions","title":"<code>getFunctions()</code>","text":"<p>Get all registered functions.</p> <p>This method exists to be consistent with the Java client.</p> RETURNS DESCRIPTION <code>functions</code> <p>List of all registered functions.</p> <p> TYPE: <code>List[StreamPipesFunction]</code> </p>"},{"location":"reference/functions/registration/#streampipes.functions.registration.Registration.register","title":"<code>register(streampipes_function)</code>","text":"<p>Registers a new function.</p> PARAMETER  DESCRIPTION <code>streampipes_function</code> <p>The function to register.</p> <p> TYPE: <code>StreamPipesFunction</code> </p> RETURNS DESCRIPTION <code>self</code> <p>The updated Registration instance</p> <p> TYPE: <code>Registration</code> </p>"},{"location":"reference/functions/streampipes_function/","title":"Streampipes function","text":""},{"location":"reference/functions/streampipes_function/#streampipes.functions.streampipes_function.StreamPipesFunction","title":"<code>StreamPipesFunction(function_definition=None)</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Abstract implementation of a StreamPipesFunction.</p> <p>A StreamPipesFunction allows users to get the data of a StreamPipes data streams easily. It makes it possible to work with the live data in python and enables to use the powerful data analytics libraries there.</p> PARAMETER  DESCRIPTION <code>function_definition</code> <p>the definition of the function that contains metadata about the connected function</p> <p> TYPE: <code>Optional[FunctionDefinition]</code> DEFAULT: <code>None</code> </p> ATTRIBUTE DESCRIPTION <code>output_collectors</code> <p>List of all output collectors which are created based on the provided function definitions.</p> <p> TYPE: <code>Dict[str, OutputCollector]</code> </p>"},{"location":"reference/functions/streampipes_function/#streampipes.functions.streampipes_function.StreamPipesFunction.add_output","title":"<code>add_output(stream_id, event)</code>","text":"<p>Send an event via an output data stream to StreamPipes</p> PARAMETER  DESCRIPTION <code>stream_id</code> <p>The id of the output data stream</p> <p> TYPE: <code>str</code> </p> <code>event</code> <p>The event which should be sent</p> <p> TYPE: <code>Dict[str, Any]</code> </p> RETURNS DESCRIPTION <code>None</code>"},{"location":"reference/functions/streampipes_function/#streampipes.functions.streampipes_function.StreamPipesFunction.getFunctionId","title":"<code>getFunctionId()</code>","text":"<p>Returns the id of the function.</p> RETURNS DESCRIPTION <code>function_id</code> <p>Identification object of the StreamPipes function</p> <p> TYPE: <code>FunctionId</code> </p>"},{"location":"reference/functions/streampipes_function/#streampipes.functions.streampipes_function.StreamPipesFunction.onEvent","title":"<code>onEvent(event, streamId)</code>  <code>abstractmethod</code>","text":"<p>Is called for every event of a data stream.</p> PARAMETER  DESCRIPTION <code>event</code> <p>The received event from the data stream.</p> <p> TYPE: <code>Dict[str, Any]</code> </p> <code>streamId</code> <p>The id of the data stream which the event belongs to.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>None</code>"},{"location":"reference/functions/streampipes_function/#streampipes.functions.streampipes_function.StreamPipesFunction.onServiceStarted","title":"<code>onServiceStarted(context)</code>  <code>abstractmethod</code>","text":"<p>Is called when the function gets started.</p> PARAMETER  DESCRIPTION <code>context</code> <p>The context in which the function gets started.</p> <p> TYPE: <code>FunctionContext</code> </p> RETURNS DESCRIPTION <code>None</code>"},{"location":"reference/functions/streampipes_function/#streampipes.functions.streampipes_function.StreamPipesFunction.onServiceStopped","title":"<code>onServiceStopped()</code>  <code>abstractmethod</code>","text":"<p>Is called when the function gets stopped.</p> RETURNS DESCRIPTION <code>None</code>"},{"location":"reference/functions/streampipes_function/#streampipes.functions.streampipes_function.StreamPipesFunction.requiredStreamIds","title":"<code>requiredStreamIds()</code>","text":"<p>Get the ids of the streams needed by the function.</p> RETURNS DESCRIPTION <code>stream_ids</code> <p>List of the stream ids</p> <p> TYPE: <code>List[str]</code> </p>"},{"location":"reference/functions/streampipes_function/#streampipes.functions.streampipes_function.StreamPipesFunction.stop","title":"<code>stop()</code>","text":"<p>Stops the function and disconnects from the output streams</p>"},{"location":"reference/functions/broker/broker/","title":"Broker","text":""},{"location":"reference/functions/broker/broker/#streampipes.functions.broker.broker.Broker","title":"<code>Broker</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Abstract implementation of a broker for consumer and publisher.</p> <p>It contains the basic logic to connect to a data stream.</p>"},{"location":"reference/functions/broker/broker/#streampipes.functions.broker.broker.Broker.connect","title":"<code>connect(data_stream)</code>  <code>async</code>","text":"<p>Connects to the broker running in StreamPipes.</p> PARAMETER  DESCRIPTION <code>data_stream</code> <p>Contains the meta information (resources) for a data stream.</p> <p> TYPE: <code>DataStream</code> </p> RETURNS DESCRIPTION <code>None</code>"},{"location":"reference/functions/broker/broker/#streampipes.functions.broker.broker.Broker.disconnect","title":"<code>disconnect()</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Closes the connection to the server.</p> RETURNS DESCRIPTION <code>None</code>"},{"location":"reference/functions/broker/broker_handler/","title":"Broker handler","text":""},{"location":"reference/functions/broker/broker_handler/#streampipes.functions.broker.broker_handler.SupportedBroker","title":"<code>SupportedBroker</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Enum for the supported brokers.</p>"},{"location":"reference/functions/broker/broker_handler/#streampipes.functions.broker.broker_handler.UnsupportedBrokerError","title":"<code>UnsupportedBrokerError(broker_name)</code>","text":"<p>             Bases: <code>Exception</code></p> <p>Exception if a broker isn't implemented yet.</p>"},{"location":"reference/functions/broker/broker_handler/#streampipes.functions.broker.broker_handler.get_broker","title":"<code>get_broker(data_stream, is_publisher=False)</code>","text":"<p>Derive the broker for the given data stream.</p> PARAMETER  DESCRIPTION <code>data_stream</code> <p>Data stream instance from which the broker is inferred</p> <p> TYPE: <code>DataStream</code> </p> RETURNS DESCRIPTION <code>broker</code> <p>The corresponding broker instance derived from data stream.</p> <p> TYPE: <code>Broker</code> </p> RAISES DESCRIPTION <code>UnsupportedBrokerError</code> <p>Is raised when the given data stream belongs to a broker that is currently not supported by StreamPipes Python.</p>"},{"location":"reference/functions/broker/broker_handler/#streampipes.functions.broker.broker_handler.get_broker_description","title":"<code>get_broker_description(data_stream)</code>","text":"<p>Derive the decription of the broker for the given data stream.</p> PARAMETER  DESCRIPTION <code>data_stream</code> <p>Data stream instance from which the broker is inferred</p> <p> TYPE: <code>DataStream</code> </p> RETURNS DESCRIPTION <code>broker</code> <p>The corresponding broker description derived from data stream.</p> <p> TYPE: <code>SupportedBroker</code> </p> RAISES DESCRIPTION <code>UnsupportedBrokerError</code> <p>Is raised when the given data stream belongs to a broker that is currently not supported by StreamPipes Python.</p>"},{"location":"reference/functions/broker/consumer/","title":"Consumer","text":""},{"location":"reference/functions/broker/consumer/#streampipes.functions.broker.consumer.Consumer","title":"<code>Consumer</code>","text":"<p>             Bases: <code>Broker</code></p> <p>Abstract implementation a consumer for a broker.</p> <p>A consumer allows to subscribe to a data stream.</p>"},{"location":"reference/functions/broker/consumer/#streampipes.functions.broker.consumer.Consumer.connect","title":"<code>connect(data_stream)</code>  <code>async</code>","text":"<p>Connects to the broker running in StreamPipes and creates a subscription.</p> PARAMETER  DESCRIPTION <code>data_stream</code> <p>Contains the meta information (resources) for a data stream.</p> <p> TYPE: <code>DataStream</code> </p> RETURNS DESCRIPTION <code>None</code>"},{"location":"reference/functions/broker/consumer/#streampipes.functions.broker.consumer.Consumer.get_message","title":"<code>get_message()</code>  <code>abstractmethod</code>","text":"<p>Get the published messages of the subscription.</p> RETURNS DESCRIPTION <code>iterator</code> <p>An async iterator for the messages.</p> <p> TYPE: <code>AsyncIterator</code> </p>"},{"location":"reference/functions/broker/output_collector/","title":"Output collector","text":""},{"location":"reference/functions/broker/output_collector/#streampipes.functions.broker.output_collector.OutputCollector","title":"<code>OutputCollector(data_stream)</code>","text":"<p>Collector for output events. The events are published to an output data stream. Therefore, the output collector establishes a connection to the broker.</p> PARAMETER  DESCRIPTION <code>data_stream</code> <p>The output data stream that will receive the events.</p> <p> TYPE: <code>DataStream</code> </p> ATTRIBUTE DESCRIPTION <code>publisher</code> <p>The publisher instance that sends the data to StreamPipes</p> <p> TYPE: <code>Publisher</code> </p>"},{"location":"reference/functions/broker/output_collector/#streampipes.functions.broker.output_collector.OutputCollector.collect","title":"<code>collect(event)</code>","text":"<p>Publishes an event to the output stream.</p> PARAMETER  DESCRIPTION <code>event</code> <p>The event to be published.</p> <p> TYPE: <code>Dict[str, Any]</code> </p> RETURNS DESCRIPTION <code>None</code>"},{"location":"reference/functions/broker/output_collector/#streampipes.functions.broker.output_collector.OutputCollector.disconnect","title":"<code>disconnect()</code>","text":"<p>Disconnects the broker of the output collector.</p> RETURNS DESCRIPTION <code>None</code>"},{"location":"reference/functions/broker/publisher/","title":"Publisher","text":""},{"location":"reference/functions/broker/publisher/#streampipes.functions.broker.publisher.Publisher","title":"<code>Publisher</code>","text":"<p>             Bases: <code>Broker</code></p> <p>Abstract implementation of a publisher for a broker.</p> <p>A publisher allows to publish events to a data stream.</p>"},{"location":"reference/functions/broker/publisher/#streampipes.functions.broker.publisher.Publisher.publish_event","title":"<code>publish_event(event)</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Publish an event to a connected data stream.</p> PARAMETER  DESCRIPTION <code>event</code> <p>The event to be published.</p> <p> TYPE: <code>Dict[str, Any]</code> </p> RETURNS DESCRIPTION <code>None</code>"},{"location":"reference/functions/broker/kafka/kafka_consumer/","title":"Kafka consumer","text":""},{"location":"reference/functions/broker/kafka/kafka_consumer/#streampipes.functions.broker.kafka.kafka_consumer.KafkaConsumer","title":"<code>KafkaConsumer</code>","text":"<p>             Bases: <code>Consumer</code></p> <p>Implementation of a consumer for Kafka</p>"},{"location":"reference/functions/broker/kafka/kafka_consumer/#streampipes.functions.broker.kafka.kafka_consumer.KafkaConsumer.disconnect","title":"<code>disconnect()</code>  <code>async</code>","text":"<p>Closes the connection to the server.</p> RETURNS DESCRIPTION <code>None</code>"},{"location":"reference/functions/broker/kafka/kafka_consumer/#streampipes.functions.broker.kafka.kafka_consumer.KafkaConsumer.get_message","title":"<code>get_message()</code>","text":"<p>Get the published messages of the subscription.</p> RETURNS DESCRIPTION <code>iterator</code> <p>An async iterator for the messages.</p> <p> TYPE: <code>AsyncIterator</code> </p>"},{"location":"reference/functions/broker/kafka/kafka_message_fetcher/","title":"Kafka message fetcher","text":""},{"location":"reference/functions/broker/kafka/kafka_message_fetcher/#streampipes.functions.broker.kafka.kafka_message_fetcher.KafkaMessage","title":"<code>KafkaMessage(data)</code>","text":"<p>An internal representation of a Kafka message</p> PARAMETER  DESCRIPTION <code>data</code> <p>The received Kafka message as byte array</p> <p> </p>"},{"location":"reference/functions/broker/kafka/kafka_message_fetcher/#streampipes.functions.broker.kafka.kafka_message_fetcher.KafkaMessageFetcher","title":"<code>KafkaMessageFetcher(consumer)</code>","text":"<p>Fetches the next message from Kafka</p> PARAMETER  DESCRIPTION <code>consumer</code> <p>The Kafka consumer</p> <p> TYPE: <code>Consumer</code> </p>"},{"location":"reference/functions/broker/kafka/kafka_publisher/","title":"Kafka publisher","text":""},{"location":"reference/functions/broker/kafka/kafka_publisher/#streampipes.functions.broker.kafka.kafka_publisher.KafkaPublisher","title":"<code>KafkaPublisher</code>","text":"<p>             Bases: <code>Publisher</code></p> <p>Implementation of a publisher for Kafka</p>"},{"location":"reference/functions/broker/kafka/kafka_publisher/#streampipes.functions.broker.kafka.kafka_publisher.KafkaPublisher.disconnect","title":"<code>disconnect()</code>  <code>async</code>","text":"<p>Closes the connection to the server.</p> RETURNS DESCRIPTION <code>None</code>"},{"location":"reference/functions/broker/kafka/kafka_publisher/#streampipes.functions.broker.kafka.kafka_publisher.KafkaPublisher.publish_event","title":"<code>publish_event(event)</code>  <code>async</code>","text":"<p>Publish an event to a connected data stream.</p> PARAMETER  DESCRIPTION <code>event</code> <p>The event to be published.</p> <p> TYPE: <code>Dict[str, Any]</code> </p> RETURNS DESCRIPTION <code>None</code>"},{"location":"reference/functions/broker/nats/nats_consumer/","title":"Nats consumer","text":""},{"location":"reference/functions/broker/nats/nats_consumer/#streampipes.functions.broker.nats.nats_consumer.NatsConsumer","title":"<code>NatsConsumer</code>","text":"<p>             Bases: <code>Consumer</code></p> <p>Implementation of a consumer for NATS</p>"},{"location":"reference/functions/broker/nats/nats_consumer/#streampipes.functions.broker.nats.nats_consumer.NatsConsumer.disconnect","title":"<code>disconnect()</code>  <code>async</code>","text":"<p>Closes the connection to the server.</p> RETURNS DESCRIPTION <code>None</code>"},{"location":"reference/functions/broker/nats/nats_consumer/#streampipes.functions.broker.nats.nats_consumer.NatsConsumer.get_message","title":"<code>get_message()</code>","text":"<p>Get the published messages of the subscription.</p> RETURNS DESCRIPTION <code>message_iterator</code> <p>An async iterator for the messages.</p> <p> TYPE: <code>AsyncIterator</code> </p>"},{"location":"reference/functions/broker/nats/nats_publisher/","title":"Nats publisher","text":""},{"location":"reference/functions/broker/nats/nats_publisher/#streampipes.functions.broker.nats.nats_publisher.NatsPublisher","title":"<code>NatsPublisher</code>","text":"<p>             Bases: <code>Publisher</code></p> <p>Implementation of a publisher for NATS</p>"},{"location":"reference/functions/broker/nats/nats_publisher/#streampipes.functions.broker.nats.nats_publisher.NatsPublisher.disconnect","title":"<code>disconnect()</code>  <code>async</code>","text":"<p>Closes the connection to the server.</p> RETURNS DESCRIPTION <code>None</code>"},{"location":"reference/functions/broker/nats/nats_publisher/#streampipes.functions.broker.nats.nats_publisher.NatsPublisher.publish_event","title":"<code>publish_event(event)</code>  <code>async</code>","text":"<p>Publish an event to a connected data stream.</p> PARAMETER  DESCRIPTION <code>event</code> <p>The event to be published.</p> <p> TYPE: <code>Dict[str, Any]</code> </p> RETURNS DESCRIPTION <code>None</code>"},{"location":"reference/functions/utils/async_iter_handler/","title":"Async iter handler","text":""},{"location":"reference/functions/utils/async_iter_handler/#streampipes.functions.utils.async_iter_handler.AsyncIterHandler","title":"<code>AsyncIterHandler</code>","text":"<p>Handles asynchronous iterators to get every message after another in parallel.</p>"},{"location":"reference/functions/utils/async_iter_handler/#streampipes.functions.utils.async_iter_handler.AsyncIterHandler.anext","title":"<code>anext(stream_id, message)</code>  <code>async</code> <code>staticmethod</code>","text":"<p>Gets the next message from an AsyncIterator.</p> PARAMETER  DESCRIPTION <code>stream_id</code> <p>The id of the data stream which the message belongs to.</p> <p> TYPE: <code>str</code> </p> <code>message</code> <p>An asynchronous iterator that contains the messages.</p> <p> TYPE: <code>AsyncIterator</code> </p> RETURNS DESCRIPTION <code>result</code> <p>Tuple of the stream id und next message or <code>(\"stop\", None)</code> if no message is left.</p> <p> TYPE: <code>Tuple[str, Optional[Any]]</code> </p>"},{"location":"reference/functions/utils/async_iter_handler/#streampipes.functions.utils.async_iter_handler.AsyncIterHandler.combine_async_messages","title":"<code>combine_async_messages(messages)</code>  <code>async</code> <code>staticmethod</code>","text":"<p>Continuously gets the next published message from multiple AsyncIterators in parallel.</p> PARAMETER  DESCRIPTION <code>messages</code> <p>A dictionary with an asynchronous iterator for every stream id.</p> <p> TYPE: <code>Dict[str, AsyncIterator]</code> </p> YIELDS DESCRIPTION <code>message</code> <p>Description of the anonymous integer return value.</p> <p> TYPE:: <code>Tuple[str, Any]</code> </p>"},{"location":"reference/functions/utils/data_stream_context/","title":"Data stream context","text":""},{"location":"reference/functions/utils/data_stream_context/#streampipes.functions.utils.data_stream_context.DataStreamContext","title":"<code>DataStreamContext(functions, schema, broker)</code>","text":"<p>Container for the context of a data stream.</p> PARAMETER  DESCRIPTION <code>functions</code> <p>StreamPipes Functions which require the data of this data stream.</p> <p> TYPE: <code>List[StreamPipesFunction]</code> </p> <code>schema</code> <p>The schema of this data stream.</p> <p> TYPE: <code>DataStream</code> </p> <code>broker</code> <p>The consumer to connect to this data stream.</p> <p> TYPE: <code>Consumer</code> </p>"},{"location":"reference/functions/utils/data_stream_context/#streampipes.functions.utils.data_stream_context.DataStreamContext.add_function","title":"<code>add_function(function)</code>","text":"<p>Adds a new StreamPipes Function.</p> PARAMETER  DESCRIPTION <code>function</code> <p>StreamPipesFunction which requires this data stream.</p> <p> TYPE: <code>StreamPipesFunction</code> </p> RETURNS DESCRIPTION <code>None</code>"},{"location":"reference/functions/utils/data_stream_generator/","title":"Data stream generator","text":""},{"location":"reference/functions/utils/data_stream_generator/#streampipes.functions.utils.data_stream_generator.RuntimeType","title":"<code>RuntimeType</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Runtime type names for the attributes of a data stream.</p> ATTRIBUTE DESCRIPTION <code>STRING</code> <p> </p> <code>BOOLEAN</code> <p> </p> <code>DOUBLE</code> <p> </p> <code>FLOAT</code> <p> </p> <code>INTEGER</code> <p> </p> <code>LONG</code> <p> </p>"},{"location":"reference/functions/utils/data_stream_generator/#streampipes.functions.utils.data_stream_generator.create_data_stream","title":"<code>create_data_stream(name, attributes, stream_id=None, broker=SupportedBroker.NATS)</code>","text":"<p>Creates a data stream</p> PARAMETER  DESCRIPTION <code>name</code> <p>Name of the data stream to be shown at the UI.</p> <p> TYPE: <code>str</code> </p> <code>attributes</code> <p>Name and types of the attributes.</p> <p> TYPE: <code>Dict[str, str]</code> </p> <code>stream_id</code> <p>The id of this data stream.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>data_stream</code> <p>The created data stream</p> <p> TYPE: <code>DataStream</code> </p>"},{"location":"reference/functions/utils/function_context/","title":"Function context","text":""},{"location":"reference/functions/utils/function_context/#streampipes.functions.utils.function_context.FunctionContext","title":"<code>FunctionContext(function_id, schema, client, streams)</code>","text":"<p>Container for the context of a StreamPipesFunction.</p> PARAMETER  DESCRIPTION <code>function_id</code> <p>The id of this function.</p> <p> TYPE: <code>str</code> </p> <code>schema</code> <p>A dictionary which contains the schema of a data stream for each stream id.</p> <p> TYPE: <code>Dict[str, DataStream]</code> </p> <code>client</code> <p>The client to interact with the API.</p> <p> TYPE: <code>StreamPipesClient</code> </p> <code>streams</code> <p>The ids of the streams needed by this function.</p> <p> TYPE: <code>List[str]</code> </p>"},{"location":"reference/functions/utils/function_context/#streampipes.functions.utils.function_context.FunctionContext.add_data_stream_schema","title":"<code>add_data_stream_schema(stream_id, data_stream)</code>","text":"<p>Adds a new data stream for a new stream id.</p> PARAMETER  DESCRIPTION <code>stream_id</code> <p>The id of the data stream.</p> <p> TYPE: <code>str</code> </p> <code>data_stream</code> <p>The schema of the data stream.</p> <p> TYPE: <code>DataStream</code> </p> RETURNS DESCRIPTION <code>None</code>"},{"location":"reference/model/common/","title":"Common","text":"<p>Classes of the StreamPipes data model that are commonly shared.</p>"},{"location":"reference/model/common/#streampipes.model.common.ApplicationLink","title":"<code>ApplicationLink</code>","text":"<p>             Bases: <code>BasicModel</code></p> <p>Data model of an <code>ApplicationLink</code> in compliance to the StreamPipes Backend.</p>"},{"location":"reference/model/common/#streampipes.model.common.BaseElement","title":"<code>BaseElement</code>","text":"<p>             Bases: <code>BasicModel</code></p> <p>Structure of a basic element in the StreamPipes backend</p>"},{"location":"reference/model/common/#streampipes.model.common.BasicModel","title":"<code>BasicModel</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Basic model class used for the whole Python StreamPipes data model.</p>"},{"location":"reference/model/common/#streampipes.model.common.BasicModel.Config","title":"<code>Config</code>","text":"<p>Configuration class for Pydantic. Defines alias generator to convert field names from camelCase (API) to snake_case (Python codebase).</p>"},{"location":"reference/model/common/#streampipes.model.common.EventGrounding","title":"<code>EventGrounding</code>","text":"<p>             Bases: <code>BasicModel</code></p> <p>Data model of an <code>EventGrounding</code> in compliance to the StreamPipes Backend.</p>"},{"location":"reference/model/common/#streampipes.model.common.EventProperty","title":"<code>EventProperty</code>","text":"<p>             Bases: <code>BasicModel</code></p> <p>Data model of an <code>EventProperty</code> in compliance to the StreamPipes Backend.</p>"},{"location":"reference/model/common/#streampipes.model.common.EventSchema","title":"<code>EventSchema</code>","text":"<p>             Bases: <code>BasicModel</code></p> <p>Data model of an <code>EventSchema</code> in compliance to the StreamPipes Backend.</p>"},{"location":"reference/model/common/#streampipes.model.common.MeasurementCapability","title":"<code>MeasurementCapability</code>","text":"<p>             Bases: <code>BasicModel</code></p> <p>Data model of a <code>MeasurementCapability</code> in compliance to the StreamPipes Backend.</p>"},{"location":"reference/model/common/#streampipes.model.common.MeasurementObject","title":"<code>MeasurementObject</code>","text":"<p>             Bases: <code>BasicModel</code></p> <p>Data model of a <code>MeasurementObject</code> in compliance to the StreamPipes Backend.</p>"},{"location":"reference/model/common/#streampipes.model.common.TopicDefinition","title":"<code>TopicDefinition</code>","text":"<p>             Bases: <code>BasicModel</code></p> <p>Data model of a <code>TopicDefinition</code> in compliance to the StreamPipes Backend.</p>"},{"location":"reference/model/common/#streampipes.model.common.TransportFormat","title":"<code>TransportFormat</code>","text":"<p>             Bases: <code>BasicModel</code></p> <p>Data model of a <code>TransportFormat</code> in compliance to the StreamPipes Backend.</p>"},{"location":"reference/model/common/#streampipes.model.common.TransportProtocol","title":"<code>TransportProtocol</code>","text":"<p>             Bases: <code>BasicModel</code></p> <p>Data model of a <code>TransportProtocol</code> in compliance to the StreamPipes Backend.</p>"},{"location":"reference/model/common/#streampipes.model.common.ValueSpecification","title":"<code>ValueSpecification</code>","text":"<p>             Bases: <code>BasicModel</code></p> <p>Data model of an <code>ValueSpecification</code> in compliance to the StreamPipes Backend.</p>"},{"location":"reference/model/common/#streampipes.model.common.random_letters","title":"<code>random_letters(n)</code>","text":"<p>Generates a string consisting of random letters.</p> PARAMETER  DESCRIPTION <code>n</code> <p>number of letters</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>rand_str</code> <p>String consisting of <code>n</code> random letters</p> <p> TYPE: <code>str</code> </p>"},{"location":"reference/model/container/data_lake_measures/","title":"Data lake measures","text":"<p>Implementation of a resource container for the data lake measures endpoint.</p>"},{"location":"reference/model/container/data_lake_measures/#streampipes.model.container.data_lake_measures.DataLakeMeasures","title":"<code>DataLakeMeasures(resources)</code>","text":"<p>             Bases: <code>ResourceContainer</code></p> <p>Implementation of the resource container for the data lake measures endpoint.</p> <p>This resource container is a collection of data lake measures returned by the StreamPipes API. It is capable of parsing the response content directly into a list of queried <code>DataLakeMeasure</code>. Furthermore, the resource container makes them accessible in a pythonic manner.</p>"},{"location":"reference/model/container/data_streams/","title":"Data streams","text":"<p>Implementation of a resource container for the data streams endpoint.</p>"},{"location":"reference/model/container/data_streams/#streampipes.model.container.data_streams.DataStreams","title":"<code>DataStreams(resources)</code>","text":"<p>             Bases: <code>ResourceContainer</code></p> <p>Implementation of the resource container for the data stream endpoint.</p> <p>This resource container is a collection of data streams returned by the StreamPipes API. It is capable of parsing the response content directly into a list of queried <code>DataStream</code>. Furthermore, the resource container makes them accessible in a pythonic manner.</p>"},{"location":"reference/model/container/resource_container/","title":"Resource container","text":"<p>General and abstract implementation for a resource container.</p> <p>A resource container is a collection of resources returned by the StreamPipes API. It is capable of parsing the response content directly into a list of queried resources. Furthermore, the resource container makes them accessible in a pythonic manner.</p>"},{"location":"reference/model/container/resource_container/#streampipes.model.container.resource_container.ResourceContainer","title":"<code>ResourceContainer(resources)</code>","text":"<p>             Bases: <code>ABC</code></p> <p>General and abstract implementation for a resource container.</p> <p>A resource container is a collection of resources returned by the StreamPipes API. It is capable of parsing the response content directly into a list of queried resources. Furthermore, the resource container makes them accessible in a pythonic manner.</p> PARAMETER  DESCRIPTION <code>resources</code> <p>A list of resources to be contained in the <code>ResourceContainer</code>.</p> <p> TYPE: <code>List[Resource]</code> </p>"},{"location":"reference/model/container/resource_container/#streampipes.model.container.resource_container.ResourceContainer.from_json","title":"<code>from_json(json_string)</code>  <code>classmethod</code>","text":"<p>Creates a <code>ResourceContainer</code> from the given JSON string.</p> PARAMETER  DESCRIPTION <code>json_string</code> <p>The JSON string returned from the StreamPipes API.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>container</code> <p>instance of the container derived from the JSON definition</p> <p> TYPE: <code>ResourceContainer</code> </p> RAISES DESCRIPTION <code>StreamPipesDataModelError</code> <p>If a resource cannot be mapped to the corresponding Python data model.</p> <code>StreamPipesResourceContainerJSONError</code> <p>If JSON response cannot be parsed to a <code>ResourceContainer</code>.</p>"},{"location":"reference/model/container/resource_container/#streampipes.model.container.resource_container.ResourceContainer.to_dicts","title":"<code>to_dicts(use_source_names=False)</code>","text":"<p>Returns the contained resources as list of dictionaries.</p> PARAMETER  DESCRIPTION <code>use_source_names</code> <p>Determines whether the field names are named in Python style (=<code>False</code>) or as originally named by StreamPipes (=<code>True</code>).</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>dictionary_list</code> <p>List of resources in dictionary representation. If <code>use_source_names</code> equals <code>True</code> the keys are named as in the StreamPipes backend.</p> <p> TYPE: <code>List[Dict[str, Any]]</code> </p>"},{"location":"reference/model/container/resource_container/#streampipes.model.container.resource_container.ResourceContainer.to_json","title":"<code>to_json()</code>","text":"<p>Returns the resource container in the StreamPipes JSON representation.</p> RETURNS DESCRIPTION <code> json_string: str</code> <p>JSON representation of the resource container where key names are equal to keys used in the StreamPipes backend</p>"},{"location":"reference/model/container/resource_container/#streampipes.model.container.resource_container.ResourceContainer.to_pandas","title":"<code>to_pandas()</code>","text":"<p>Returns the resource container in representation of a Pandas Dataframe.</p> RETURNS DESCRIPTION <code>resource_container_df</code> <p>Representation of the resource container as pandas DataFrame</p> <p> TYPE: <code>DataFrame</code> </p>"},{"location":"reference/model/container/resource_container/#streampipes.model.container.resource_container.StreamPipesDataModelError","title":"<code>StreamPipesDataModelError(validation_error)</code>","text":"<p>             Bases: <code>Exception</code></p> <p>A custom exception to be raised when a validation error occurs during the parsing of StreamPipes API responses.</p> PARAMETER  DESCRIPTION <code>validation_error</code> <p>The validation error thrown by Pydantic during parsing.</p> <p> TYPE: <code>ValidationError</code> </p>"},{"location":"reference/model/container/resource_container/#streampipes.model.container.resource_container.StreamPipesResourceContainerJSONError","title":"<code>StreamPipesResourceContainerJSONError(container_name, json_string)</code>","text":"<p>             Bases: <code>Exception</code></p> <p>A custom exception to be raised when the returned JSON string does not suit to the structure of resource container.</p> PARAMETER  DESCRIPTION <code>container_name</code> <p>The class name of the resource container where the invalid data structure was detected.</p> <p> TYPE: <code>str</code> </p> <code>json_string</code> <p>The JSON string that has been tried to parse.</p> <p> TYPE: <code>str</code> </p>"},{"location":"reference/model/container/versions/","title":"Versions","text":"<p>Implementation of a resource container for the versions endpoint.</p>"},{"location":"reference/model/container/versions/#streampipes.model.container.versions.Versions","title":"<code>Versions(resources)</code>","text":"<p>             Bases: <code>ResourceContainer</code></p> <p>Implementation of the resource container for the versions endpoint.</p> <p>This resource container is a collection of versions returned by the StreamPipes API. It is capable of parsing the response content directly into a list of queried <code>Version</code>. Furthermore, the resource container makes them accessible in a pythonic manner.</p> PARAMETER  DESCRIPTION <code>resources</code> <p>A list of resources (Version) to be contained in the <code>ResourceContainer</code>.</p> <p> TYPE: <code>List[Resource]</code> </p>"},{"location":"reference/model/resource/data_lake_measure/","title":"Data lake measure","text":""},{"location":"reference/model/resource/data_lake_measure/#streampipes.model.resource.data_lake_measure.DataLakeMeasure","title":"<code>DataLakeMeasure</code>","text":"<p>             Bases: <code>Resource</code></p> <p>Implementation of a resource for data lake measures.</p> <p>This resource defines the data model used by resource container (<code>model.container.DataLakeMeasures</code>). It inherits from Pydantic's BaseModel to get all its superpowers, which are used to parse, validate the API response, and to easily switch between the Python representation (both serialized and deserialized) and Java representation (serialized only).</p>"},{"location":"reference/model/resource/data_lake_measure/#streampipes.model.resource.data_lake_measure.DataLakeMeasure.convert_to_pandas_representation","title":"<code>convert_to_pandas_representation()</code>","text":"<p>Returns the dictionary representation of a data lake measure to be used when creating a pandas Dataframe.</p> <p>It excludes the following fields: <code>element_id</code>, <code>event_schema</code>, <code>schema_version</code>. Instead of the whole event schema the number of event properties contained is returned with the column name <code>num_event_properties</code>.</p> RETURNS DESCRIPTION <code>pandas_repr</code> <p>Pandas representation of the resource as a dictionary, which is then used by the respource container to create a data frame from a collection of resources.</p> <p> TYPE: <code>Dict[str, Any]</code> </p>"},{"location":"reference/model/resource/data_series/","title":"Data series","text":""},{"location":"reference/model/resource/data_series/#streampipes.model.resource.data_series.DataSeries","title":"<code>DataSeries</code>","text":"<p>             Bases: <code>Resource</code></p> <p>Implementation of a resource for data series. This resource defines the data model used by its resource container(<code>model.container.DataLakeMeasures</code>). It inherits from Pydantic's BaseModel to get all its superpowers, which are used to parse, validate the API response and to easily switch between the Python representation (both serialized and deserialized) and Java representation (serialized only).</p> Notes <pre><code>This class will only exist temporarily in it its current appearance since\nthere are some inconsistencies in the StreamPipes API.\n</code></pre>"},{"location":"reference/model/resource/data_series/#streampipes.model.resource.data_series.DataSeries.convert_to_pandas_representation","title":"<code>convert_to_pandas_representation()</code>","text":"<p>Returns the dictionary representation of a data lake series to be used when creating a pandas Dataframe.</p> <p>It contains only the \"header rows\" (the column names) and \"rows\" that contain the actual data.</p> RETURNS DESCRIPTION <code>pandas_repr</code> <p>Dictionary with the keys <code>headers</code> and <code>rows</code></p> <p> TYPE: <code>dict[str, Any]</code> </p>"},{"location":"reference/model/resource/data_series/#streampipes.model.resource.data_series.DataSeries.from_json","title":"<code>from_json(json_string)</code>  <code>classmethod</code>","text":"<p>Creates an instance of <code>DataSeries</code> from a given JSON string.</p> <p>This method is used by the resource container to parse the JSON response of the StreamPipes API. Currently, it only supports data lake series that consist of exactly one series of data.</p> PARAMETER  DESCRIPTION <code>json_string</code> <p>The JSON string the data lake series should be created on.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>DataSeries</code> <p>Instance of <code>DataSeries</code> that is created based on the given JSON string.</p> RAISES DESCRIPTION <code>StreamPipesUnsupportedDataLakeSeries</code> <p>If the data lake series returned by the StreamPipes API cannot be parsed with the current version of the Python client.</p>"},{"location":"reference/model/resource/data_series/#streampipes.model.resource.data_series.DataSeries.to_pandas","title":"<code>to_pandas()</code>","text":"<p>Returns the data lake series in representation of a Pandas Dataframe.</p> RETURNS DESCRIPTION <code>pd</code> <p>The data lake series in form of a pandas dataframe</p> <p> TYPE: <code>DataFrame</code> </p>"},{"location":"reference/model/resource/data_stream/","title":"Data stream","text":""},{"location":"reference/model/resource/data_stream/#streampipes.model.resource.data_stream.DataStream","title":"<code>DataStream(**kwargs)</code>","text":"<p>             Bases: <code>Resource</code></p> <p>Implementation of a resource for data streams.</p> <p>This resource defines the data model used by resource container (<code>model.container.DataStreams</code>). It inherits from Pydantic's BaseModel to get all its superpowers, which are used to parse, validate the API response and to easily switch between the Python representation (both serialized and deserialized) and Java representation (serialized only).</p>"},{"location":"reference/model/resource/data_stream/#streampipes.model.resource.data_stream.DataStream.convert_to_pandas_representation","title":"<code>convert_to_pandas_representation()</code>","text":"<p>Returns the dictionary representation of a data stream to be used when creating a pandas Dataframe.</p> RETURNS DESCRIPTION <code>pandas_repr</code> <p>Pandas representation of the resource as a dictionary, which is then used by the respource container to create a data frame from a collection of resources.</p> <p> TYPE: <code>Dict[str, Any]</code> </p>"},{"location":"reference/model/resource/data_stream/#streampipes.model.resource.data_stream.DataStream.to_dict","title":"<code>to_dict(use_source_names=True)</code>","text":"<p>Returns the resource in dictionary representation.</p> PARAMETER  DESCRIPTION <code>use_source_names</code> <p>Indicates if the dictionary keys are in python representation or equally named to the StreamPipes backend</p> <p> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>resource</code> <p>The resource as dictionary representation</p> <p> TYPE: <code>Dict[str, Any]</code> </p>"},{"location":"reference/model/resource/exceptions/","title":"Exceptions","text":""},{"location":"reference/model/resource/exceptions/#streampipes.model.resource.exceptions.StreamPipesUnsupportedDataSeries","title":"<code>StreamPipesUnsupportedDataSeries(reason=None)</code>","text":"<p>             Bases: <code>Exception</code></p> <p>Exception to be raised when the returned data lake series cannot be parsed with the current implementation of the resource.</p>"},{"location":"reference/model/resource/function_definition/","title":"Function definition","text":""},{"location":"reference/model/resource/function_definition/#streampipes.model.resource.function_definition.FunctionDefinition","title":"<code>FunctionDefinition</code>","text":"<p>             Bases: <code>Resource</code></p> <p>Configuration for a StreamPipes Function.</p> <p>This class maps to the <code>FunctionDefinition</code> class in the StreamPipes model. It contains all metadata that are required to register a function at the StreamPipes backend.</p> ATTRIBUTE DESCRIPTION <code>consumed_streams</code> <p>List of data streams the function is consuming from</p> <p> TYPE: <code>List[str]</code> </p> <code>function_id</code> <p>identifier object of a StreamPipes function</p> <p> TYPE: <code>FunctionId</code> </p> <code>output_data_streams</code> <p>Map off all output data streams added to the function definition</p> <p> TYPE: <code>Dict[str, DataStream]</code> </p>"},{"location":"reference/model/resource/function_definition/#streampipes.model.resource.function_definition.FunctionDefinition.add_output_data_stream","title":"<code>add_output_data_stream(data_stream)</code>","text":"<p>Adds an output data stream to the function which makes it possible to write data back to StreamPipes.</p> PARAMETER  DESCRIPTION <code>data_stream</code> <p>The schema of the output data stream.</p> <p> TYPE: <code>DataStream</code> </p> RETURNS DESCRIPTION <code>self</code> <p>Instance of the function definition that is extended by the provided <code>DataStream</code></p> <p> TYPE: <code>FunctionDefinition</code> </p>"},{"location":"reference/model/resource/function_definition/#streampipes.model.resource.function_definition.FunctionDefinition.convert_to_pandas_representation","title":"<code>convert_to_pandas_representation()</code>","text":"<p>Returns the dictionary representation of a function definition to be used when creating a pandas Dataframe.</p> RETURNS DESCRIPTION <code>pandas_repr</code> <p>Pandas representation of the resource as a dictionary, which is then used by the respource container to create a data frame from a collection of resources.</p> <p> TYPE: <code>Dict[str, Any]</code> </p>"},{"location":"reference/model/resource/function_definition/#streampipes.model.resource.function_definition.FunctionDefinition.get_output_data_streams","title":"<code>get_output_data_streams()</code>","text":"<p>Get the output data streams of the function.</p> RETURNS DESCRIPTION <code>output_streams</code> <p>Dictionary with every known stream id and the related output stream.</p> <p> TYPE: <code>Dict[str, DataStream]</code> </p>"},{"location":"reference/model/resource/function_definition/#streampipes.model.resource.function_definition.FunctionDefinition.get_output_stream_ids","title":"<code>get_output_stream_ids()</code>","text":"<p>Get the stream ids of the output data streams.</p> RETURNS DESCRIPTION <code>output_stream_ids</code> <p>List of all stream ids</p> <p> TYPE: <code>List[str]</code> </p>"},{"location":"reference/model/resource/function_definition/#streampipes.model.resource.function_definition.FunctionId","title":"<code>FunctionId</code>","text":"<p>             Bases: <code>BasicModel</code></p> <p>Identification object for a StreamPipes function.</p> <p>Maps to the <code>FunctionId</code> class defined in the StreamPipes model.</p> ATTRIBUTE DESCRIPTION <code>id</code> <p>unique identifier of the function instance</p> <p> TYPE: <code>str</code> </p> <code>version</code> <p>version of the corresponding function</p> <p> TYPE: <code>int</code> </p>"},{"location":"reference/model/resource/query_result/","title":"Query result","text":""},{"location":"reference/model/resource/query_result/#streampipes.model.resource.query_result.QueryResult","title":"<code>QueryResult</code>","text":"<p>             Bases: <code>Resource</code></p> <p>Implementation of a resource for query result. This resource defines the data model used by its resource container(<code>model.container.DataLakeMeasures</code>). It inherits from Pydantic's BaseModel to get all its superpowers, which are used to parse, validate the API response and to easily switch between the Python representation (both serialized and deserialized) and Java representation (serialized only).</p>"},{"location":"reference/model/resource/query_result/#streampipes.model.resource.query_result.QueryResult.convert_to_pandas_representation","title":"<code>convert_to_pandas_representation()</code>","text":"<p>Returns the dictionary representation of a data lake series to be used when creating a pandas Dataframe.</p> <p>It contains only the \"header rows\" (the column names) and \"rows\" that contain the actual data.</p> RETURNS DESCRIPTION <code>dict</code> <p>Dictionary with the keys <code>headers</code> and <code>rows</code></p> RAISES DESCRIPTION <code>StreamPipesUnsupportedDataLakeSeries</code> <p>If the query result returned by the StreamPipes API cannot be converted to the pandas representation</p>"},{"location":"reference/model/resource/query_result/#streampipes.model.resource.query_result.QueryResult.to_pandas","title":"<code>to_pandas()</code>","text":"<p>Returns the data lake series in representation of a Pandas Dataframe.</p> RETURNS DESCRIPTION <code>df</code> <p>Pandas df containing the query result</p> <p> TYPE: <code>DataFrame</code> </p>"},{"location":"reference/model/resource/resource/","title":"Resource","text":"<p>General and abstract implementation for a resource.</p> <p>A resource defines the data model that is used by a resource container (<code>model.container.resourceContainer</code>).</p>"},{"location":"reference/model/resource/resource/#streampipes.model.resource.resource.Resource","title":"<code>Resource</code>","text":"<p>             Bases: <code>ABC</code>, <code>BasicModel</code></p> <p>General and abstract implementation for a resource.</p> <p>A resource defines the data model used by a resource container (<code>model.container.resourceContainer</code>). It inherits from Pydantic's BaseModel to get all its superpowers, which are used to parse, validate the API response and to easily switch between the Python representation (both serialized and deserialized) and Java representation (serialized only).</p>"},{"location":"reference/model/resource/resource/#streampipes.model.resource.resource.Resource.convert_to_pandas_representation","title":"<code>convert_to_pandas_representation()</code>  <code>abstractmethod</code>","text":"<p>Returns a dictionary representation to be used when creating a pandas Dataframe.</p> RETURNS DESCRIPTION <code>pandas_repr</code> <p>Pandas representation of the resource as a dictionary, which is then used by the respource container to create a data frame from a collection of resources.</p> <p> TYPE: <code>Dict[str, Any]</code> </p>"},{"location":"reference/model/resource/resource/#streampipes.model.resource.resource.Resource.to_dict","title":"<code>to_dict(use_source_names=True)</code>","text":"<p>Returns the resource in dictionary representation.</p> PARAMETER  DESCRIPTION <code>use_source_names</code> <p>Indicates if the dictionary keys are in python representation or equally named to the StreamPipes backend</p> <p> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>resource</code> <p>The resource as dictionary representation</p> <p> TYPE: <code>Dict[str, Any]</code> </p>"},{"location":"reference/model/resource/version/","title":"Version","text":""},{"location":"reference/model/resource/version/#streampipes.model.resource.version.Version","title":"<code>Version</code>","text":"<p>             Bases: <code>Resource</code></p> <p>Metadata about the version of the connected StreamPipes server.</p> ATTRIBUTE DESCRIPTION <code>backend_version</code> <p>version of the StreamPipes backend the client is connected to</p> <p> TYPE: <code>str</code> </p>"},{"location":"reference/model/resource/version/#streampipes.model.resource.version.Version.convert_to_pandas_representation","title":"<code>convert_to_pandas_representation()</code>","text":"<p>Returns the dictionary representation of the version metadata to be used when creating a pandas Dataframe.</p>"},{"location":"reference/model/resource/version/#streampipes.model.resource.version.Version.validate_backend_version","title":"<code>validate_backend_version(backend_version)</code>","text":"<p>Validates the backend version of the StreamPipes. Sets 'development' if none is returned since this the behavior of StreamPipes backend running in development mode.</p>"},{"location":"scripts/gen_ref_pages/","title":"Gen ref pages","text":"<p>Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements.  See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License.  You may obtain a copy of the License at</p> <p>http://www.apache.org/licenses/LICENSE-2.0</p> <p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p> In\u00a0[\u00a0]: Copied! <pre>from pathlib import Path\n</pre> from pathlib import Path In\u00a0[\u00a0]: Copied! <pre>import mkdocs_gen_files\n</pre> import mkdocs_gen_files In\u00a0[\u00a0]: Copied! <pre>nav = mkdocs_gen_files.Nav()\n</pre> nav = mkdocs_gen_files.Nav() In\u00a0[\u00a0]: Copied! <pre>for path in sorted(Path(\"streampipes\").rglob(\"*.py\")):\n    module_path = path.relative_to(\"streampipes\").with_suffix(\"\")\n    doc_path = path.relative_to(\"streampipes\").with_suffix(\".md\")\n    full_doc_path = Path(\"reference\", doc_path)\n\n    parts = list(module_path.parts)\n\n    if parts[-1] == \"__init__\":\n        # parts = parts[:-1]\n        continue\n    elif parts[-1] == \"__version__\":\n        continue\n    elif parts[-1] == \"__main__\":\n        continue\n    elif parts[-1] == \" \":\n        continue\n\n    nav[parts] = doc_path.as_posix()\n\n    with mkdocs_gen_files.open(full_doc_path, \"w+\") as fd:\n        identifier = \".\".join(parts)\n        print(f\"::: streampipes.{identifier}\", file=fd)\n\n    mkdocs_gen_files.set_edit_path(full_doc_path, path)\n</pre> for path in sorted(Path(\"streampipes\").rglob(\"*.py\")):     module_path = path.relative_to(\"streampipes\").with_suffix(\"\")     doc_path = path.relative_to(\"streampipes\").with_suffix(\".md\")     full_doc_path = Path(\"reference\", doc_path)      parts = list(module_path.parts)      if parts[-1] == \"__init__\":         # parts = parts[:-1]         continue     elif parts[-1] == \"__version__\":         continue     elif parts[-1] == \"__main__\":         continue     elif parts[-1] == \" \":         continue      nav[parts] = doc_path.as_posix()      with mkdocs_gen_files.open(full_doc_path, \"w+\") as fd:         identifier = \".\".join(parts)         print(f\"::: streampipes.{identifier}\", file=fd)      mkdocs_gen_files.set_edit_path(full_doc_path, path) <p>with mkdocs_gen_files.open(\"reference/SUMMARY.md\", \"w+\") as nav_file: nav_file.writelines(nav.build_literate_nav())</p>"},{"location":"tutorials/1-introduction-to-streampipes-python-client/","title":"Introduction to StreamPipes Python","text":"In\u00a0[\u00a0]: Copied! <pre>%pip install streampipes\n</pre> %pip install streampipes  <p>If you want to have the current development state you can also execute:</p> In\u00a0[\u00a0]: Copied! <pre>%pip install git+https://github.com/apache/streampipes.git#subdirectory=streampipes-client-python\n</pre>  %pip install git+https://github.com/apache/streampipes.git#subdirectory=streampipes-client-python <p>The corresponding documentation can be found here. </p> In\u00a0[\u00a0]: Copied! <pre>from streampipes.client import StreamPipesClient\nfrom streampipes.client.config import StreamPipesClientConfig\nfrom streampipes.client.credential_provider import StreamPipesApiKeyCredentials\n</pre> from streampipes.client import StreamPipesClient from streampipes.client.config import StreamPipesClientConfig from streampipes.client.credential_provider import StreamPipesApiKeyCredentials In\u00a0[\u00a0]: Copied! <pre>config = StreamPipesClientConfig(\n    credential_provider=StreamPipesApiKeyCredentials(\n        username=\"test@streampipes.apache.org\",\n        api_key=\"API-KEY\",\n    ),\n    host_address=\"localhost\",\n    https_disabled=True,\n    port=80\n)\n</pre> config = StreamPipesClientConfig(     credential_provider=StreamPipesApiKeyCredentials(         username=\"test@streampipes.apache.org\",         api_key=\"API-KEY\",     ),     host_address=\"localhost\",     https_disabled=True,     port=80 ) <p>Please be aware that connecting to StreamPipes via a <code>https</code> connection is currently not supported by the Python client.</p> <p>Providing secrets like the <code>api_key</code> as plaintext in the source code is an anti-pattern. This is why the StreamPipes client also supports passing the required secrets as environment variables. To do so, you must initialize the credential provider like the following:</p> In\u00a0[\u00a0]: Copied! <pre>StreamPipesApiKeyCredentials()\n</pre> StreamPipesApiKeyCredentials() <p>To ensure that the above code works, you must set the environment variables as expected. This can be done like following:</p> In\u00a0[\u00a0]: Copied! <pre>import os\nos.environ[\"SP_USERNAME\"] = \"admin@streampipes.apache.org\"\nos.environ[\"SP_API_KEY\"] = \"XXX\"\n</pre> import os os.environ[\"SP_USERNAME\"] = \"admin@streampipes.apache.org\" os.environ[\"SP_API_KEY\"] = \"XXX\"  <p>Having the <code>config</code> ready, we can now initialize the actual client.</p> In\u00a0[\u00a0]: Copied! <pre>client = StreamPipesClient(client_config=config)\n</pre> client = StreamPipesClient(client_config=config) <p>That's already it. You can check if everything works out by using the following command:</p> In\u00a0[6]: Copied! <pre>client.describe()\n</pre> client.describe() <pre>2023-02-24 17:05:49,398 - streampipes.endpoint.endpoint - [INFO] - [endpoint.py:167] [_make_request] - Successfully retrieved all resources.\n2023-02-24 17:05:49,457 - streampipes.endpoint.endpoint - [INFO] - [endpoint.py:167] [_make_request] - Successfully retrieved all resources.\n\nHi there!\nYou are connected to a StreamPipes instance running at http://localhost:80.\nThe following StreamPipes resources are available with this client:\n1x DataLakeMeasures\n1x DataStreams\n</pre> <p>This prints you a short textual description of the connected StreamPipes instance to the console.</p> <p>The created <code>client</code> instance serves as the central point of interaction with StreamPipes. You can invoke a variety of commands directly on this object.</p> <p>Are you curious now how you actually can get data out of StreamPipes and make use of it with Python? Then check out the next tutorial on extracting Data from the StreamPipes data lake.</p> <p>Thanks for reading this introductory tutorial. We hope you like it and would love to receive some feedback from you. Just go to our GitHub discussion page and let us know your impression. We'll read and react to them all, we promise!</p>"},{"location":"tutorials/1-introduction-to-streampipes-python-client/#Introduction-to-StreamPipes-Python","title":"Introduction to StreamPipes Python\u00b6","text":""},{"location":"tutorials/1-introduction-to-streampipes-python-client/#Why-there-is-an-extra-Python-library-for-StreamPipes?","title":"Why there is an extra Python library for StreamPipes?\u00b6","text":"<p>Apache StreamPipes aims to enable non-technical users to connect and analyze IoT data streams. To this end, it provides an easy-to-use and convenient user interface that allows one to connect to an IoT data source and create some visual graphs within a few minutes.  Although this is the main use case of Apache StreamPipes, it can also provide great value for people who are eager to work on data analysis or data science with IoT data, but don't we do get in touch with all the hassle associated with extracting data from devices in a suitable format. In this scenario, StreamPipes helps you connect to your data source and extract the data for you. You then can make the data available outside StreamPipes by writing it into an external source, such as a database, Kafka, etc. While this requires another component, you can also extract your data directly from StreamPipes programmatically using the StreamPipes API. For convenience, we also provide you with a StreamPipes client both available for Java and Python. Specifically with StreamPipes Python, we want to address the amazing data analytics and data science community in Python and benefit from the great universe of Python libraries out there.</p>"},{"location":"tutorials/1-introduction-to-streampipes-python-client/#How-to-install-StreamPipes-Python?","title":"How to install StreamPipes Python?\u00b6","text":"<p>Simply use the following <code>pip</code> command:</p>"},{"location":"tutorials/1-introduction-to-streampipes-python-client/#How-to-prepare-the-tutorials","title":"How to prepare the tutorials\u00b6","text":"<p>In case you want to reproduce the first two tutorials exactly on your end, you need to create a simple pipeline in StreamPipes like demonstrated below.</p> <p></p>"},{"location":"tutorials/1-introduction-to-streampipes-python-client/#How-to-configure-the-Python-client","title":"How to configure the Python client\u00b6","text":"<p>In order to access the resources available in StreamPipes, one must be able to authenticate against the backend. For this purpose, the client sofar only supports the authentication via an API token that can be generated via the StreamPipes UI, as you see below.</p> <p></p> <p>Having generated the API token, one can directly start initializing a client instance as follows:</p>"},{"location":"tutorials/2-extracting-data-from-the-streampipes-data-lake/","title":"Extracting Data from the StreamPipes data lake","text":"In\u00a0[1]: Copied! <pre>from streampipes.client import StreamPipesClient\nfrom streampipes.client.config import StreamPipesClientConfig\nfrom streampipes.client.credential_provider import StreamPipesApiKeyCredentials\n</pre> from streampipes.client import StreamPipesClient from streampipes.client.config import StreamPipesClientConfig from streampipes.client.credential_provider import StreamPipesApiKeyCredentials In\u00a0[\u00a0]: Copied! <pre># if you want all necessary dependencies required for this tutorial to be installed,\n# you can simply execute the following command\n%pip install matplotlib streampipes\n</pre> # if you want all necessary dependencies required for this tutorial to be installed, # you can simply execute the following command %pip install matplotlib streampipes In\u00a0[2]: Copied! <pre>import os\nos.environ[\"SP_USERNAME\"] = \"admin@streampipes.apache.org\"\nos.environ[\"SP_API_KEY\"] = \"XXX\"\n</pre> import os os.environ[\"SP_USERNAME\"] = \"admin@streampipes.apache.org\" os.environ[\"SP_API_KEY\"] = \"XXX\"  In\u00a0[3]: Copied! <pre>config = StreamPipesClientConfig(\n    credential_provider=StreamPipesApiKeyCredentials(),\n    host_address=\"localhost\",\n    https_disabled=True,\n    port=80\n)\n</pre> config = StreamPipesClientConfig(     credential_provider=StreamPipesApiKeyCredentials(),     host_address=\"localhost\",     https_disabled=True,     port=80 ) In\u00a0[4]: Copied! <pre>client = StreamPipesClient(client_config=config)\n</pre> client = StreamPipesClient(client_config=config) <pre>2023-02-24 17:34:25,860 - streampipes.client.client - [INFO] - [client.py:128] [_set_up_logging] - Logging successfully initialized with logging level INFO.\n</pre> <p>As a first step, we want to get an overview about all data available in the data lake. The data is stored as so-called <code>measures</code>, which refer to a data stream stored in the data lake. For his purpose we use the <code>all()</code> method of the <code>dataLakeMeasure</code> endpoint.</p> In\u00a0[5]: Copied! <pre>data_lake_measures = client.dataLakeMeasureApi.all()\n</pre> data_lake_measures = client.dataLakeMeasureApi.all() <pre>2023-02-24 17:34:25,929 - streampipes.endpoint.endpoint - [INFO] - [endpoint.py:167] [_make_request] - Successfully retrieved all resources.\n</pre> <p>So let's see how many measures are available</p> In\u00a0[6]: Copied! <pre>len(data_lake_measures)\n</pre> len(data_lake_measures) Out[6]: <pre>2</pre> <p>All resources of the StreamPipes Python client support the standard Python expressions. If not, please let us know.</p> In\u00a0[7]: Copied! <pre>data_lake_measures[-1]\n</pre> data_lake_measures[-1] Out[7]: <pre>DataLakeMeasure(element_id='3cb6b5e6f107452483d1fd2ccf4bf9f9', measure_name='test', timestamp_field='s0::timestamp', event_schema=EventSchema(event_properties=[EventProperty(class_name='org.apache.streampipes.model.schema.EventPropertyPrimitive', element_id='sp:eventproperty:EiFnkL', label='Density', description='Denotes the current density of the fluid', runtime_name='density', required=False, domain_properties=['http://schema.org/Number'], property_scope='MEASUREMENT_PROPERTY', index=5, runtime_id=None, runtime_type='http://www.w3.org/2001/XMLSchema#float', measurement_unit=None, value_specification=None), EventProperty(class_name='org.apache.streampipes.model.schema.EventPropertyPrimitive', element_id='sp:eventproperty:ghSkQI', label='Mass Flow', description='Denotes the current mass flow in the sensor', runtime_name='mass_flow', required=False, domain_properties=['http://schema.org/Number'], property_scope='MEASUREMENT_PROPERTY', index=2, runtime_id=None, runtime_type='http://www.w3.org/2001/XMLSchema#float', measurement_unit=None, value_specification=None), EventProperty(class_name='org.apache.streampipes.model.schema.EventPropertyPrimitive', element_id='sp:eventproperty:cQAUry', label='Sensor ID', description='The ID of the sensor', runtime_name='sensorId', required=False, domain_properties=['https://streampipes.org/vocabulary/examples/watertank/v1/hasSensorId'], property_scope='DIMENSION_PROPERTY', index=1, runtime_id=None, runtime_type='http://www.w3.org/2001/XMLSchema#string', measurement_unit=None, value_specification=None), EventProperty(class_name='org.apache.streampipes.model.schema.EventPropertyPrimitive', element_id='sp:eventproperty:pbPMyL', label='Sensor Fault Flags', description='Any fault flags of the sensors', runtime_name='sensor_fault_flags', required=False, domain_properties=['http://schema.org/Boolean'], property_scope='MEASUREMENT_PROPERTY', index=6, runtime_id=None, runtime_type='http://www.w3.org/2001/XMLSchema#boolean', measurement_unit=None, value_specification=None), EventProperty(class_name='org.apache.streampipes.model.schema.EventPropertyPrimitive', element_id='sp:eventproperty:Qmayhw', label='Temperature', description='Denotes the current temperature in degrees celsius', runtime_name='temperature', required=False, domain_properties=['http://schema.org/Number'], property_scope='MEASUREMENT_PROPERTY', index=4, runtime_id=None, runtime_type='http://www.w3.org/2001/XMLSchema#float', measurement_unit='http://qudt.org/vocab/unit#DegreeCelsius', value_specification=ValueSpecification(class_name='org.apache.streampipes.model.schema.QuantitativeValue', element_id=None, min_value=0, max_value=100, step=0.1)), EventProperty(class_name='org.apache.streampipes.model.schema.EventPropertyPrimitive', element_id='sp:eventproperty:YQYhjd', label='Volume Flow', description='Denotes the current volume flow', runtime_name='volume_flow', required=False, domain_properties=['http://schema.org/Number'], property_scope='MEASUREMENT_PROPERTY', index=3, runtime_id=None, runtime_type='http://www.w3.org/2001/XMLSchema#float', measurement_unit=None, value_specification=None)]), pipeline_id=None, pipeline_name=None, pipeline_is_running=False, schema_version='1.1')</pre> <p>To get a more comprehensive overview, you can take a look at the <code>pandas</code> representation</p> In\u00a0[8]: Copied! <pre>display(data_lake_measures.to_pandas())\n</pre> display(data_lake_measures.to_pandas()) measure_name timestamp_field pipeline_id pipeline_name pipeline_is_running num_event_properties 0 flow-rate s0::timestamp None None False 6 1 test s0::timestamp None None False 6 <p>So far, we have only retrieved metadata about the available data lake measure. In the following, we will access the actual data of the measure <code>flow-rate</code>.</p> <p>For this purpose, we will use the <code>get()</code> method of the <code>dataLakeMeasure</code> endpoint.</p> In\u00a0[9]: Copied! <pre>flow_rate_measure = client.dataLakeMeasureApi.get(identifier=\"flow-rate\")\n</pre> flow_rate_measure = client.dataLakeMeasureApi.get(identifier=\"flow-rate\") <pre>2023-02-24 17:34:26,020 - streampipes.endpoint.endpoint - [INFO] - [endpoint.py:167] [_make_request] - Successfully retrieved all resources.\n</pre> <p>For further processing, the easiest way is to turn the data measure into a <code>pandas DataFrame</code>.</p> In\u00a0[10]: Copied! <pre>flow_rate_pd = flow_rate_measure.to_pandas()\n</pre> flow_rate_pd = flow_rate_measure.to_pandas() <p>Let's see how many data points we got...</p> In\u00a0[11]: Copied! <pre>len(flow_rate_pd)\n</pre> len(flow_rate_pd) Out[11]: <pre>1000</pre> <p>... and get a first overview</p> In\u00a0[12]: Copied! <pre>flow_rate_pd.describe()\n</pre> flow_rate_pd.describe() Out[12]: density mass_flow temperature volume_flow count 1000.000000 1000.000000 1000.000000 1000.000000 mean 45.560337 5.457014 45.480231 5.659558 std 3.201544 3.184959 3.132878 3.122437 min 40.007698 0.004867 40.000992 0.039422 25% 42.819497 2.654101 42.754623 3.021625 50% 45.679264 5.382355 45.435944 5.572553 75% 48.206881 8.183144 48.248473 8.338209 max 50.998310 10.986015 50.964909 10.998676 <p>As a final step, we want to create a plot of both attributes</p> In\u00a0[13]: Copied! <pre>import matplotlib.pyplot as plt\nflow_rate_pd.plot(y=[\"mass_flow\", \"temperature\"])\nplt.show()\n</pre> import matplotlib.pyplot as plt flow_rate_pd.plot(y=[\"mass_flow\", \"temperature\"]) plt.show() <p>For data lake measurements, the <code>get()</code> method is even more powerful than simply returning all the data for a given data lake measurement. We will look at a selection of these below. The full list of supported parameters can be found in the docs.  Let's start by referring to the graph we created above, where we use only two columns of our data lake measurement. If we already know this, we can directly restrict the queried data to a subset of columns by using the <code>columns</code> parameter.  <code>columns</code> takes a list of column names as a comma-separated string:</p> In\u00a0[14]: Copied! <pre>flow_rate_pd = client.dataLakeMeasureApi.get(identifier=\"flow-rate\", columns=\"mass_flow,temperature\").to_pandas()\nflow_rate_pd\n</pre> flow_rate_pd = client.dataLakeMeasureApi.get(identifier=\"flow-rate\", columns=\"mass_flow,temperature\").to_pandas() flow_rate_pd <pre>2023-02-24 17:34:26,492 - streampipes.endpoint.endpoint - [INFO] - [endpoint.py:167] [_make_request] - Successfully retrieved all resources.\n</pre> Out[14]: timestamp mass_flow temperature 0 2023-02-24T16:19:41.472Z 3.309556 44.448483 1 2023-02-24T16:19:41.482Z 5.608580 40.322033 2 2023-02-24T16:19:41.493Z 7.692881 49.239639 3 2023-02-24T16:19:41.503Z 3.632898 49.933754 4 2023-02-24T16:19:41.513Z 0.711260 50.106617 ... ... ... ... 995 2023-02-24T16:19:52.927Z 1.740114 46.558231 996 2023-02-24T16:19:52.94Z 7.211723 48.048622 997 2023-02-24T16:19:52.952Z 7.770180 48.188026 998 2023-02-24T16:19:52.965Z 4.458602 48.280899 999 2023-02-24T16:19:52.977Z 2.592060 47.505951 <p>1000 rows \u00d7 3 columns</p> <p>By default, the client returns only the first one thousand records of a Data Lake measurement. This can be changed by passing a concrete value for the <code>limit</code> parameter:</p> In\u00a0[15]: Copied! <pre>flow_rate_pd = client.dataLakeMeasureApi.get(identifier=\"flow-rate\", limit=10000).to_pandas()\nlen(flow_rate_pd)\n</pre> flow_rate_pd = client.dataLakeMeasureApi.get(identifier=\"flow-rate\", limit=10000).to_pandas() len(flow_rate_pd) <pre>2023-02-24 17:34:26,736 - streampipes.endpoint.endpoint - [INFO] - [endpoint.py:167] [_make_request] - Successfully retrieved all resources.\n</pre> Out[15]: <pre>9528</pre> <p>If you want your data to be selected by time of occurrence rather than quantity, you can specify your time window by passing the <code>start_date</code> and <code>end_date</code> parameters:</p> In\u00a0[16]: Copied! <pre>from datetime import datetime\nflow_rate_pd = client.dataLakeMeasureApi.get(\n    identifier=\"flow-rate\",\n    start_date=datetime(year=2023, month=2, day=24, hour=17, minute=21, second=0),\n    end_date=datetime(year=2023, month=2, day=24, hour=17, minute=21, second=1),\n    ).to_pandas()\nflow_rate_pd.plot(y=[\"mass_flow\", \"temperature\"])\nplt.show()\n</pre> from datetime import datetime flow_rate_pd = client.dataLakeMeasureApi.get(     identifier=\"flow-rate\",     start_date=datetime(year=2023, month=2, day=24, hour=17, minute=21, second=0),     end_date=datetime(year=2023, month=2, day=24, hour=17, minute=21, second=1),     ).to_pandas() flow_rate_pd.plot(y=[\"mass_flow\", \"temperature\"]) plt.show() <pre>2023-02-24 17:34:26,899 - streampipes.endpoint.endpoint - [INFO] - [endpoint.py:167] [_make_request] - Successfully retrieved all resources.\n</pre> <p>... from this point on we leave all future processing of the data up to your creativity. Keep in mind: the general syntax used in this tutorial (<code>all()</code>, <code>to_pandas()</code>, <code>get()</code>) applies to all endpoints and associated resources of the StreamPipes Python client.</p> <p>If you get further and create exiting stuff with data extracted from StreamPipes please let us know. We are thrilled to see what you as a community will build with the provided client. Furthermore, don't hesitate to discuss feature requests to extend the current functionality with us.</p> <p>For now, that's all about the StreamPipes client. Read the next tutorial (Getting live data from the StreamPipes data stream) if you are interested in making use of the powerful StreamPipes functions to interact with StreamPipes event-based.</p> <p>How do you like this tutorial? We hope you like it and would love to receive some feedback from you. Just go to our GitHub discussion page and let us know your impression. We'll read and react to them all, we promise!</p>"},{"location":"tutorials/2-extracting-data-from-the-streampipes-data-lake/#Extracting-Data-from-the-StreamPipes-data-lake","title":"Extracting Data from the StreamPipes data lake\u00b6","text":"<p>In the first tutorial (Introduction to the StreamPipes Python client) we took the first steps with the StreamPipes Python client and learned how to set everything up. Now we are ready to get started and want to retrieve some data out of StreamPipes. In this tutorial, we'll focus on the StreamPipes Data Lake, the component where StreamPipes stores data internally. To get started, we'll use the <code>client</code> instance created in the first tutorial.</p>"},{"location":"tutorials/3-getting-live-data-from-the-streampipes-data-stream/","title":"Getting live data from the StreamPipes data stream","text":"<p>Note As of now we mainly developed the support for StreamPipes functions using NATS as messaging protocol. Consequently, this setup is tested most and should work flawlessly. Visit our first-steps page to see how to start StreamPipes accordingly. Anyhow, you can also use the other brokers that are currently supported in StreamPipes Python. In case you observe any problems, please reach out to us and file us an issue on GitHub.</p> In\u00a0[1]: Copied! <pre>from streampipes.client import StreamPipesClient\nfrom streampipes.client.config import StreamPipesClientConfig\nfrom streampipes.client.credential_provider import StreamPipesApiKeyCredentials\n</pre> from streampipes.client import StreamPipesClient from streampipes.client.config import StreamPipesClientConfig from streampipes.client.credential_provider import StreamPipesApiKeyCredentials In\u00a0[\u00a0]: Copied! <pre># You can install all required libraries for this tutorial with the following command\n%pip install matplotlib ipython streampipes\n</pre> # You can install all required libraries for this tutorial with the following command %pip install matplotlib ipython streampipes In\u00a0[2]: Copied! <pre>import os\n\nos.environ[\"SP_USERNAME\"] = \"admin@streampipes.apache.org\"\nos.environ[\"SP_API_KEY\"] = \"XXX\"\n\n# Use this if you work locally:\nos.environ[\"BROKER-HOST\"] = \"localhost\"  \nos.environ[\"KAFKA-PORT\"] = \"9094\" # When using Kafka as message broker. If Kafka is not running on localhost, KAFKA_ADVERTISED_LISTENERS should be adjusted to the external address\n</pre> import os  os.environ[\"SP_USERNAME\"] = \"admin@streampipes.apache.org\" os.environ[\"SP_API_KEY\"] = \"XXX\"  # Use this if you work locally: os.environ[\"BROKER-HOST\"] = \"localhost\"   os.environ[\"KAFKA-PORT\"] = \"9094\" # When using Kafka as message broker. If Kafka is not running on localhost, KAFKA_ADVERTISED_LISTENERS should be adjusted to the external address In\u00a0[3]: Copied! <pre>client_config = StreamPipesClientConfig(\n    credential_provider=StreamPipesApiKeyCredentials(),\n    host_address=\"localhost\",\n    port=80,\n    https_disabled=True,\n)\nclient = StreamPipesClient(client_config=client_config)\n</pre> client_config = StreamPipesClientConfig(     credential_provider=StreamPipesApiKeyCredentials(),     host_address=\"localhost\",     port=80,     https_disabled=True, ) client = StreamPipesClient(client_config=client_config) <pre>2022-12-14 10:43:37,664 - streampipes.client.client - [INFO] - [client.py:127] [_set_up_logging] - Logging successfully initialized with logging level INFO.\n</pre> <p>Now we can have a look at the available data streams. We can choose one or more stream to receive the data from and copy their <code>element_id</code>.</p> In\u00a0[4]: Copied! <pre>client.dataStreamApi.all().to_pandas()\n</pre> client.dataStreamApi.all().to_pandas() <pre>2022-12-14 10:43:39,944 - streampipes.endpoint.endpoint - [INFO] - [endpoint.py:153] [_make_request] - Successfully retrieved all resources.\n</pre> Out[4]: element_id name description icon_url app_id includes_assets includes_locales internally_managed measurement_object index ... uri dom num_transport_protocols num_measurement_capability num_application_links num_included_assets num_connected_to num_category num_event_properties num_included_locales 0 urn:streampipes.apache.org:eventstream:HHoidJ Test2 None None False False True None 0 ... urn:streampipes.apache.org:eventstream:HHoidJ None 1 0 0 0 0 0 7 0 1 urn:streampipes.apache.org:eventstream:uPDKLI Test None None False False True None 0 ... urn:streampipes.apache.org:eventstream:uPDKLI None 1 0 0 0 0 0 7 0 <p>2 rows \u00d7 21 columns</p> <p>Next we can create a StreamPipesFunction. For this we need to implement the 3 following methods:</p> <ul> <li><code>onServiceStarted</code> is called when the function gets started. There you can use the given meta information of the <code>FunctionContext</code> to initialize the function.</li> <li><code>onEvent</code> is called when ever a new event arrives. The <code>event</code> contains the live data and you can use the <code>streamId</code> to identify a stream if the function is connected to multiple data streams.</li> <li><code>onServiceStopped</code> is called when the function gets stopped.</li> </ul> <p>For this tutorial we just create a function that saves every new event in a <code>pandas DataFrame</code> and plots the first column of the <code>DataFrame</code> when the function gets stopped.</p> <p>(If you want to use the same structure as in Java you can overwrite the <code>getFunctionId</code> and <code>requiredStreamIds</code> methods instead of using the <code>FunctionDefinition</code>)</p> In\u00a0[5]: Copied! <pre>from typing import Dict, Any\nimport pandas as pd\nfrom datetime import datetime\nimport matplotlib.pyplot as plt\nfrom streampipes.functions.function_handler import FunctionHandler\nfrom streampipes.functions.registration import Registration\nfrom streampipes.functions.streampipes_function import StreamPipesFunction\nfrom streampipes.functions.utils.function_context import FunctionContext\nfrom streampipes.model.resource.function_definition import FunctionDefinition, FunctionId\n\nclass ExampleFunction(StreamPipesFunction):\n    def __init__(self, function_definition: FunctionDefinition) -&gt; None:\n        super().__init__(function_definition)\n        # Create the Dataframe to save the live data\n        self.df = pd.DataFrame()\n\n    def onServiceStarted(self, context: FunctionContext):\n        # Get the name of the timestamp field\n        for event_property in context.schema[context.streams[0]].event_schema.event_properties:\n            if event_property.property_scope == \"HEADER_PROPERTY\":\n                self.timestamp = event_property.runtime_name\n\n    def onEvent(self, event: Dict[str, Any], streamId: str):\n        # Convert the unix timestamp to datetime\n        event[self.timestamp] = datetime.fromtimestamp(event[self.timestamp] / 1000)\n        # Add every value of the event to the DataFrame\n        self.df = pd.concat(\n            [self.df, pd.DataFrame({key: [event[key]] for key in event.keys()}).set_index(self.timestamp)]\n        )\n\n    def onServiceStopped(self):\n        # Plot the first column of the Dataframe\n        plt.figure(figsize=(10, 5))\n        plt.xlabel(self.timestamp)\n        plt.ylabel(self.df.columns[0])\n        plt.plot(self.df.iloc[:, 0])\n        plt.show()\n</pre> from typing import Dict, Any import pandas as pd from datetime import datetime import matplotlib.pyplot as plt from streampipes.functions.function_handler import FunctionHandler from streampipes.functions.registration import Registration from streampipes.functions.streampipes_function import StreamPipesFunction from streampipes.functions.utils.function_context import FunctionContext from streampipes.model.resource.function_definition import FunctionDefinition, FunctionId  class ExampleFunction(StreamPipesFunction):     def __init__(self, function_definition: FunctionDefinition) -&gt; None:         super().__init__(function_definition)         # Create the Dataframe to save the live data         self.df = pd.DataFrame()      def onServiceStarted(self, context: FunctionContext):         # Get the name of the timestamp field         for event_property in context.schema[context.streams[0]].event_schema.event_properties:             if event_property.property_scope == \"HEADER_PROPERTY\":                 self.timestamp = event_property.runtime_name      def onEvent(self, event: Dict[str, Any], streamId: str):         # Convert the unix timestamp to datetime         event[self.timestamp] = datetime.fromtimestamp(event[self.timestamp] / 1000)         # Add every value of the event to the DataFrame         self.df = pd.concat(             [self.df, pd.DataFrame({key: [event[key]] for key in event.keys()}).set_index(self.timestamp)]         )      def onServiceStopped(self):         # Plot the first column of the Dataframe         plt.figure(figsize=(10, 5))         plt.xlabel(self.timestamp)         plt.ylabel(self.df.columns[0])         plt.plot(self.df.iloc[:, 0])         plt.show() <p>Now we can start the function. First we create an instance of the <code>ExampleFunction</code> and insert the <code>element_id</code> of the stream which data we want to consume. Then we have to register this function and we can start all functions by initializing the <code>FunctionHandler</code>. (it's also possible to register multiple functions with <code>.register(...).register(...)</code>)</p> In\u00a0[6]: Copied! <pre>example_function = ExampleFunction(\n    FunctionDefinition(\n        function_id=FunctionId(id=\"example-function\"),\n        consumed_streams=[\"urn:streampipes.apache.org:eventstream:uPDKLI\"]\n    )\n)\n\nregistration = Registration()\nregistration.register(example_function)\n\nfunction_handler = FunctionHandler(registration, client)\nfunction_handler.initializeFunctions()\n</pre> example_function = ExampleFunction(     FunctionDefinition(         function_id=FunctionId(id=\"example-function\"),         consumed_streams=[\"urn:streampipes.apache.org:eventstream:uPDKLI\"]     ) )  registration = Registration() registration.register(example_function)  function_handler = FunctionHandler(registration, client) function_handler.initializeFunctions() <pre>2022-12-14 10:43:42,810 - streampipes.endpoint.endpoint - [INFO] - [endpoint.py:153] [_make_request] - Successfully retrieved all resources.\n2022-12-14 10:43:42,812 - streampipes.functions.function_handler - [INFO] - [function_handler.py:82] [initializeFunctions] - Using NatsBroker for &lt;__main__.ExampleFunction object at 0x000001F2EF298D90&gt;\n</pre> <p>The <code>DataFrame</code> of the <code>ExampleFunction</code> gets updated whenever a new event arrives. Let's test this by executing the cell below.</p> In\u00a0[7]: Copied! <pre>import asyncio\nfrom asyncio.exceptions import CancelledError\nfrom IPython.display import clear_output\n\nwhile True:\n    clear_output(wait=True)\n    display(example_function.df)\n    try:\n        await asyncio.sleep(1)\n    except CancelledError:\n        break\n</pre> import asyncio from asyncio.exceptions import CancelledError from IPython.display import clear_output  while True:     clear_output(wait=True)     display(example_function.df)     try:         await asyncio.sleep(1)     except CancelledError:         break mass_flow density volume_flow sensor_fault_flags temperature sensorId timestamp 2022-12-14 10:43:43.357 10.955496 47.546290 1.001985 False 44.993413 flowrate02 2022-12-14 10:43:44.371 6.499040 44.392069 2.034402 False 41.232352 flowrate02 2022-12-14 10:43:45.382 10.168300 41.192146 9.724287 False 46.812779 flowrate02 2022-12-14 10:43:46.395 10.849059 50.086308 5.832691 False 45.860412 flowrate02 2022-12-14 10:43:47.410 3.081855 47.254246 8.860531 False 50.505801 flowrate02 ... ... ... ... ... ... ... 2022-12-14 10:44:43.920 1.803572 41.978894 10.294002 False 47.820239 flowrate02 2022-12-14 10:44:44.932 1.967062 42.212883 3.237440 False 49.047258 flowrate02 2022-12-14 10:44:45.934 4.457819 47.561256 0.315024 False 40.223413 flowrate02 2022-12-14 10:44:46.949 8.745343 46.346891 7.439090 False 41.982529 flowrate02 2022-12-14 10:44:47.950 5.828744 47.679720 6.307405 False 42.100354 flowrate02 <p>65 rows \u00d7 6 columns</p> <p>The <code>while</code> loop just displays the the <code>DataFrame</code> every second until the cell is stopped. We could achieve the same result manually by executing <code>example_function.df</code> repeatedly.</p> <p>You can stop the functions whenever you want by executing the command below.</p> In\u00a0[\u00a0]: Copied! <pre>function_handler.disconnect()\n</pre> function_handler.disconnect() <pre>2022-12-14 10:44:53,309 - streampipes.functions.broker.nats_broker - [INFO] - [nats_broker.py:67] [disconnect] - Stopped connection to stream: urn:streampipes.apache.org:eventstream:uPDKLI\n</pre> <p>That's enough for this tutorial. Now you can try to write your own <code>StreamPipesFunction</code>. All you need to do is creating a new class, implementing the 4 required methods and registering the function.</p> <p>Want to see more exciting use cases you can achieve with StreamPipes functions in Python? Then don't hesitate and jump to our next tutorial on applying online machine learning algorithms to StreamPipes data streams with River.</p> <p>How do you like this tutorial? We hope you like it and would love to receive some feedback from you. Just go to our GitHub discussion page and let us know your impression. We'll read and react to them all, we promise!</p>"},{"location":"tutorials/3-getting-live-data-from-the-streampipes-data-stream/#Getting-live-data-from-the-StreamPipes-data-stream","title":"Getting live data from the StreamPipes data stream\u00b6","text":"<p>In the last tutorial (Extracting Data from the StreamPipes data lake) we learned how to extract the stored data from a StreamPipes data lake. This tutorial is about the StreamPipes data stream and shows how to get the live data from StreamPipes into Python. Therefore, we first create the <code>client</code> instance as before.</p>"},{"location":"tutorials/4-using-online-machine-learning-on-a-streampipes-data-stream/","title":"Using Online Machine Learning on a StreamPipes data stream","text":"In\u00a0[1]: Copied! <pre>from streampipes.client import StreamPipesClient\nfrom streampipes.client.config import StreamPipesClientConfig\nfrom streampipes.client.credential_provider import StreamPipesApiKeyCredentials\n</pre> from streampipes.client import StreamPipesClient from streampipes.client.config import StreamPipesClientConfig from streampipes.client.credential_provider import StreamPipesApiKeyCredentials In\u00a0[\u00a0]: Copied! <pre># you can install all required dependencies for this tutorial by executing the following command\n%pip install river streampipes\n</pre> # you can install all required dependencies for this tutorial by executing the following command %pip install river streampipes In\u00a0[2]: Copied! <pre>import os\n\nos.environ[\"SP_USERNAME\"] = \"admin@streampipes.apache.org\"\nos.environ[\"SP_API_KEY\"] = \"XXX\"\n\n# Use this if you work locally:\nos.environ[\"BROKER-HOST\"] = \"localhost\"  \nos.environ[\"KAFKA-PORT\"] = \"9094\" # When using Kafka as message broker\n</pre> import os  os.environ[\"SP_USERNAME\"] = \"admin@streampipes.apache.org\" os.environ[\"SP_API_KEY\"] = \"XXX\"  # Use this if you work locally: os.environ[\"BROKER-HOST\"] = \"localhost\"   os.environ[\"KAFKA-PORT\"] = \"9094\" # When using Kafka as message broker In\u00a0[3]: Copied! <pre>client_config = StreamPipesClientConfig(\n    credential_provider=StreamPipesApiKeyCredentials(),\n    host_address=\"localhost\",\n    port=80,\n    https_disabled=True,\n)\nclient = StreamPipesClient(client_config=client_config)\n</pre> client_config = StreamPipesClientConfig(     credential_provider=StreamPipesApiKeyCredentials(),     host_address=\"localhost\",     port=80,     https_disabled=True, ) client = StreamPipesClient(client_config=client_config) <pre>2023-01-27 16:04:24,784 - streampipes.client.client - [INFO] - [client.py:128] [_set_up_logging] - Logging successfully initialized with logging level INFO.\n</pre> In\u00a0[4]: Copied! <pre>client.dataStreamApi.all().to_pandas()\n</pre> client.dataStreamApi.all().to_pandas() <pre>2023-01-27 16:04:28,212 - streampipes.endpoint.endpoint - [INFO] - [endpoint.py:163] [_make_request] - Successfully retrieved all resources.\n</pre> Out[4]: element_id name description icon_url app_id includes_assets includes_locales internally_managed measurement_object index ... dom rev num_transport_protocols num_measurement_capability num_application_links num_included_assets num_connected_to num_category num_event_properties num_included_locales 0 sp:spdatastream:xboBFK Test None None False False True None 0 ... None 5-558c861debc745e1ebae29a266a8bdb9 1 0 0 0 0 0 7 0 1 urn:streampipes.apache.org:eventstream:Wgyrse Test File None None False False True None 0 ... None 4-66548b6b84287011b7cec0876ef82baf 1 0 0 0 0 0 2 0 <p>2 rows \u00d7 22 columns</p> In\u00a0[5]: Copied! <pre>from river import cluster, compose, preprocessing\nfrom streampipes.function_zoo.river_function import OnlineML\nfrom streampipes.functions.utils.data_stream_generator import RuntimeType\n\nk_means = compose.Pipeline(\n    (\"drop_features\", compose.Discard(\"sensorId\", \"timestamp\")),\n    (\"scale\", preprocessing.StandardScaler()),\n    (\"k_means\", cluster.KMeans(n_clusters=2)),\n)\n\nclustering = OnlineML(\n    client=client, stream_ids=[\"sp:spdatastream:xboBFK\"], model=k_means, prediction_type=RuntimeType.INTEGER.value\n)\nclustering.start()\n</pre> from river import cluster, compose, preprocessing from streampipes.function_zoo.river_function import OnlineML from streampipes.functions.utils.data_stream_generator import RuntimeType  k_means = compose.Pipeline(     (\"drop_features\", compose.Discard(\"sensorId\", \"timestamp\")),     (\"scale\", preprocessing.StandardScaler()),     (\"k_means\", cluster.KMeans(n_clusters=2)), )  clustering = OnlineML(     client=client, stream_ids=[\"sp:spdatastream:xboBFK\"], model=k_means, prediction_type=RuntimeType.INTEGER.value ) clustering.start() <pre>2023-01-27 16:04:35,599 - streampipes.endpoint.endpoint - [INFO] - [endpoint.py:163] [_make_request] - Successfully retrieved all resources.\n2023-01-27 16:04:35,599 - streampipes.functions.function_handler - [INFO] - [function_handler.py:64] [initializeFunctions] - Create output data stream \"sp:spdatastream:cwKPoo\" for the function \"65cf8b86-bcdf-433e-a1c7-3e920eab55d0\"\n2023-01-27 16:04:37,766 - streampipes.endpoint.endpoint - [INFO] - [endpoint.py:163] [_make_request] - Successfully retrieved all resources.\n2023-01-27 16:04:37,767 - streampipes.functions.function_handler - [INFO] - [function_handler.py:78] [initializeFunctions] - Using NatsBroker for RiverFunction\n</pre> <pre>2023-01-27 16:04:37,791 - streampipes.functions.broker.nats_broker - [INFO] - [nats_broker.py:48] [_makeConnection] - Connected to NATS at localhost:4222\n2023-01-27 16:04:37,791 - streampipes.functions.broker.nats_broker - [INFO] - [nats_broker.py:48] [_makeConnection] - Connected to NATS at localhost:4222\n2023-01-27 16:04:37,792 - streampipes.functions.broker.nats_broker - [INFO] - [nats_broker.py:58] [createSubscription] - Subscribed to stream: sp:spdatastream:xboBFK\n</pre> In\u00a0[6]: Copied! <pre>clustering.set_learning(False)\n</pre> clustering.set_learning(False) In\u00a0[\u00a0]: Copied! <pre>clustering.stop()\n</pre> clustering.stop() <pre>2023-01-27 16:04:57,303 - streampipes.functions.broker.nats_broker - [INFO] - [nats_broker.py:82] [disconnect] - Stopped connection to stream: sp:spdatastream:xboBFK\n2023-01-27 16:04:57,304 - streampipes.functions.broker.nats_broker - [INFO] - [nats_broker.py:82] [disconnect] - Stopped connection to stream: sp:spdatastream:cwKPoo\n</pre> In\u00a0[\u00a0]: Copied! <pre>import pickle\nfrom river import compose, tree\nfrom streampipes.function_zoo.river_function import OnlineML\nfrom streampipes.functions.utils.data_stream_generator import RuntimeType\n\nhoeffding_tree = compose.Pipeline(\n    (\"drop_features\", compose.Discard(\"sensorId\", \"timestamp\")),\n    (\"hoeffding_tree\", tree.HoeffdingTreeRegressor(grace_period=5)),\n)\n\n\ndef draw_tree(self, event, streamId):\n\"\"\"Draw the tree and save the image.\"\"\"\n    if self.learning:\n        if self.model[1].n_nodes != None:\n            self.model[1].draw().render(\"hoeffding_tree\", format=\"png\", cleanup=True)\n\n\ndef save_model(self):\n\"\"\"Save the trained model.\"\"\"\n    with open(\"hoeffding_tree.pkl\", \"wb\") as f:\n        pickle.dump(self.model, f)\n\n\nregressor = OnlineML(\n    client=client,\n    stream_ids=[\"sp:spdatastream:xboBFK\"],\n    model=hoeffding_tree,\n    prediction_type=RuntimeType.FLOAT.value,\n    supervised=True,\n    target_label=\"temperature\",\n    on_event=draw_tree,\n    on_stop=save_model,\n)\nregressor.start()\n</pre> import pickle from river import compose, tree from streampipes.function_zoo.river_function import OnlineML from streampipes.functions.utils.data_stream_generator import RuntimeType  hoeffding_tree = compose.Pipeline(     (\"drop_features\", compose.Discard(\"sensorId\", \"timestamp\")),     (\"hoeffding_tree\", tree.HoeffdingTreeRegressor(grace_period=5)), )   def draw_tree(self, event, streamId):     \"\"\"Draw the tree and save the image.\"\"\"     if self.learning:         if self.model[1].n_nodes != None:             self.model[1].draw().render(\"hoeffding_tree\", format=\"png\", cleanup=True)   def save_model(self):     \"\"\"Save the trained model.\"\"\"     with open(\"hoeffding_tree.pkl\", \"wb\") as f:         pickle.dump(self.model, f)   regressor = OnlineML(     client=client,     stream_ids=[\"sp:spdatastream:xboBFK\"],     model=hoeffding_tree,     prediction_type=RuntimeType.FLOAT.value,     supervised=True,     target_label=\"temperature\",     on_event=draw_tree,     on_stop=save_model, ) regressor.start() In\u00a0[9]: Copied! <pre>regressor.set_learning(False)\n</pre> regressor.set_learning(False) In\u00a0[\u00a0]: Copied! <pre>regressor.stop()\n</pre> regressor.stop() In\u00a0[\u00a0]: Copied! <pre>import pickle\nfrom river import compose, tree\nfrom streampipes.function_zoo.river_function import OnlineML\nfrom streampipes.functions.utils.data_stream_generator import RuntimeType\n\ndecision_tree = compose.Pipeline(\n    (\"drop_features\", compose.Discard(\"sensorId\", \"timestamp\")),\n    (\"decision_tree\", tree.ExtremelyFastDecisionTreeClassifier(grace_period=5)),\n)\n\n\ndef draw_tree(self, event, streamId):\n\"\"\"Draw the tree and save the image.\"\"\"\n    if self.learning:\n        if self.model[1].n_nodes != None:\n            self.model[1].draw().render(\"decicion_tree\", format=\"png\", cleanup=True)\n\n\ndef save_model(self):\n\"\"\"Save the trained model.\"\"\"\n    with open(\"decision_tree.pkl\", \"wb\") as f:\n        pickle.dump(self.model, f)\n\n\nclassifier = OnlineML(\n    client=client,\n    stream_ids=[\"sp:spdatastream:xboBFK\"],\n    model=decision_tree,\n    prediction_type=RuntimeType.BOOLEAN.value,\n    supervised=True,\n    target_label=\"sensor_fault_flags\",\n    on_event=draw_tree,\n    on_stop=save_model,\n)\nclassifier.start()\n</pre> import pickle from river import compose, tree from streampipes.function_zoo.river_function import OnlineML from streampipes.functions.utils.data_stream_generator import RuntimeType  decision_tree = compose.Pipeline(     (\"drop_features\", compose.Discard(\"sensorId\", \"timestamp\")),     (\"decision_tree\", tree.ExtremelyFastDecisionTreeClassifier(grace_period=5)), )   def draw_tree(self, event, streamId):     \"\"\"Draw the tree and save the image.\"\"\"     if self.learning:         if self.model[1].n_nodes != None:             self.model[1].draw().render(\"decicion_tree\", format=\"png\", cleanup=True)   def save_model(self):     \"\"\"Save the trained model.\"\"\"     with open(\"decision_tree.pkl\", \"wb\") as f:         pickle.dump(self.model, f)   classifier = OnlineML(     client=client,     stream_ids=[\"sp:spdatastream:xboBFK\"],     model=decision_tree,     prediction_type=RuntimeType.BOOLEAN.value,     supervised=True,     target_label=\"sensor_fault_flags\",     on_event=draw_tree,     on_stop=save_model, ) classifier.start() In\u00a0[12]: Copied! <pre>classifier.set_learning(False)\n</pre> classifier.set_learning(False) In\u00a0[\u00a0]: Copied! <pre>classifier.stop()\n</pre> classifier.stop() <p>That's already it! Isn't it truly easy to apply Online ML with StreamPipes and River? Please go ahead and apply it to your own use cases. We would be happy to hear about them!</p> <p>Want to see more exciting use cases you can achieve with StreamPipes functions in Python? Then don\u2019t hesitate and jump to our next tutorial on using interoperable machine learning algorithm models with StreamPipes Python and ONNX.</p> <p>How do you like this tutorial? We hope you like it and would love to receive some feedback from you. Just go to our GitHub discussion page and let us know your impression. We'll read and react to them all, we promise!</p>"},{"location":"tutorials/4-using-online-machine-learning-on-a-streampipes-data-stream/#Using-Online-Machine-Learning-on-a-StreamPipes-data-stream","title":"Using Online Machine Learning on a StreamPipes data stream\u00b6","text":"<p>The last tutorial (Getting live data from the StreamPipes data stream) showed how we can connect to a data stream, and it would be possible to use Online Machine Learning with this approach and train a model with the incoming events at the <code>onEvent</code> method. However, the StreamPipes client also provides an easier way to do this with the use of the River library for Online Machine Learning. We will have a look at this now.</p>"},{"location":"tutorials/4-using-online-machine-learning-on-a-streampipes-data-stream/#How-to-use-Online-Machine-Learning-with-StreamPipes","title":"How to use Online Machine Learning with StreamPipes\u00b6","text":"<p>After we configured the client as usual, we can start with the new part. The approach is straight forward and you can start with the ML part in just 3 steps:</p> <ol> <li>Create a pipeline with River and insert the preprocessing steps and model of your choice.</li> <li>Configure the <code>OnlineML</code> wrapper to fit to your model and insert the client and required data stream ids.</li> <li>Start the wrapper and let the learning begin.</li> </ol> <p>A StreamPipesFunction is then started, which trains the model for each new event. It also creates an output data stream which will send the prediction of the model back to StreamPipes. This output stream can be seen when creating a new pipeline and can be used like every other data source. So you can use it in a pipeline and save the predictions in a Data Lake. You can also stop and start the training with the method <code>set_learning</code>. To stop the whole function use the <code>stop</code> methode and if you want to delete the output stream entirely, you can go to the <code>Pipeline Element Installer</code> in StreamPipes and uninstall it.</p> <p>Now let's take a look at some examples. If you want to execute the examples below you have to create an adapter for the <code>Machine Data Simulator</code>, select the <code>flowrate</code> sensor and insert the stream id of this stream.</p>"},{"location":"tutorials/4-using-online-machine-learning-on-a-streampipes-data-stream/#KMeans","title":"KMeans\u00b6","text":""},{"location":"tutorials/4-using-online-machine-learning-on-a-streampipes-data-stream/#HoeffdingTreeRegressor","title":"HoeffdingTreeRegressor\u00b6","text":""},{"location":"tutorials/4-using-online-machine-learning-on-a-streampipes-data-stream/#DecisionTreeClassifier","title":"DecisionTreeClassifier\u00b6","text":""},{"location":"tutorials/5-applying-interoperable-machine-learning-in-streampipes/","title":"Applying Interoperable Machine Learning in StreamPipes","text":"In\u00a0[\u00a0]: Copied! <pre>%pip install git+https://github.com/apache/streampipes.git#subdirectory=streampipes-client-python\n%pip install scikit-learn==1.4.0 skl2onnx==1.16.0 onnxruntime==1.17.1 matplotlib==3.8.3\n</pre> %pip install git+https://github.com/apache/streampipes.git#subdirectory=streampipes-client-python %pip install scikit-learn==1.4.0 skl2onnx==1.16.0 onnxruntime==1.17.1 matplotlib==3.8.3 In\u00a0[8]: Copied! <pre>import os\nfrom streampipes.client import StreamPipesClient\nfrom streampipes.client.config import StreamPipesClientConfig\nfrom streampipes.client.credential_provider import StreamPipesApiKeyCredentials\n\nos.environ[\"BROKER-HOST\"] = \"localhost\"\nos.environ[\"KAFKA-PORT\"] = \"9094\"  # When using Kafka as message broker\n\nconfig = StreamPipesClientConfig(\n    credential_provider=StreamPipesApiKeyCredentials(\n        username=\"admin@streampipes.apache.org\",\n        api_key=\"TOKEN\",\n    ),\n    host_address=\"localhost\",\n    https_disabled=True,\n    port=80\n)\n\nclient = StreamPipesClient(client_config=config)\n</pre> import os from streampipes.client import StreamPipesClient from streampipes.client.config import StreamPipesClientConfig from streampipes.client.credential_provider import StreamPipesApiKeyCredentials  os.environ[\"BROKER-HOST\"] = \"localhost\" os.environ[\"KAFKA-PORT\"] = \"9094\"  # When using Kafka as message broker  config = StreamPipesClientConfig(     credential_provider=StreamPipesApiKeyCredentials(         username=\"admin@streampipes.apache.org\",         api_key=\"TOKEN\",     ),     host_address=\"localhost\",     https_disabled=True,     port=80 )  client = StreamPipesClient(client_config=config) <pre>2024-03-26 10:21:38,538 - streampipes.client.client - [INFO] - [client.py:198] [_set_up_logging] - Logging successfully initialized with logging level INFO.\n2024-03-26 10:21:38,632 - streampipes.endpoint.endpoint - [INFO] - [endpoint.py:164] [_make_request] - Successfully retrieved all resources.\n2024-03-26 10:21:38,634 - streampipes.client.client - [INFO] - [client.py:171] [_get_server_version] - The StreamPipes version was successfully retrieved from the backend: 0.95.0. By means of that, authentication via the provided credentials is also tested successfully.\n</pre> <p>The main objective of this tutorial is to demonstrate how to make predictions with an existing and pre-trained ML model using a StreamPipes function and ONNX. Therefore, you can skip the following sections on use case and model training if you already have an existing ONNX model and are only interested in applying it using StreamPipes.</p> In\u00a0[9]: Copied! <pre>flowrate_df = client.dataLakeMeasureApi.get(\"flow-rate\").to_pandas()\nX = flowrate_df[\"volume_flow\"].values.reshape(-1, 1).astype(\"float32\")\n</pre> flowrate_df = client.dataLakeMeasureApi.get(\"flow-rate\").to_pandas() X = flowrate_df[\"volume_flow\"].values.reshape(-1, 1).astype(\"float32\") <pre>2024-03-26 10:21:48,582 - streampipes.endpoint.endpoint - [INFO] - [endpoint.py:164] [_make_request] - Successfully retrieved all resources.\n</pre> <p>Let's fit the model to the data:</p> In\u00a0[14]: Copied! <pre>from sklearn.ensemble import IsolationForest\n\nmodel = IsolationForest(contamination=0.01)\nmodel.fit(X)\n</pre> from sklearn.ensemble import IsolationForest  model = IsolationForest(contamination=0.01) model.fit(X) Out[14]: <pre>IsolationForest(contamination=0.01)</pre>In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.\u00a0\u00a0IsolationForest?Documentation for IsolationForestiFitted<pre>IsolationForest(contamination=0.01)</pre> <p>The <code>contamination</code> parameter models the proportion of outliers in the data. See the scikit-learn documentation for more information.</p> <p>Before we convert the model to an ONNX representation, let's do a quick visual analysis of the model results:</p> In\u00a0[15]: Copied! <pre>import matplotlib.pyplot as plt\n\nflowrate_df[\"anomaly\"] = model.predict(X)\n\nfig, ax = plt.subplots(figsize=(10, 6))\nanomalies = flowrate_df.loc[flowrate_df[\"anomaly\"] == -1, [\"volume_flow\"]]\nax.plot(flowrate_df.index, flowrate_df['volume_flow'], color='black', label='volume_flow')\nax.scatter(anomalies.index, anomalies['volume_flow'], color='red', label='Anomaly')\nplt.legend()\nplt.show()\n</pre> import matplotlib.pyplot as plt  flowrate_df[\"anomaly\"] = model.predict(X)  fig, ax = plt.subplots(figsize=(10, 6)) anomalies = flowrate_df.loc[flowrate_df[\"anomaly\"] == -1, [\"volume_flow\"]] ax.plot(flowrate_df.index, flowrate_df['volume_flow'], color='black', label='volume_flow') ax.scatter(anomalies.index, anomalies['volume_flow'], color='red', label='Anomaly') plt.legend() plt.show() <p>Okay, that looks quite reasonable so lets covert the model to an ONNX representation so that we can make use of it later.</p> In\u00a0[16]: Copied! <pre>from onnxconverter_common import FloatTensorType\nfrom skl2onnx import to_onnx\n\nmodel_onnx = to_onnx(\n    model,\n    initial_types=[('input', FloatTensorType([None, X.shape[1]]))],\n    target_opset={'ai.onnx.ml': 3, 'ai.onnx': 15, '': 15}\n)\n\nwith open(\"isolation_forest.onnx\", \"wb\") as f:\n    f.write(model_onnx.SerializeToString())\n</pre> from onnxconverter_common import FloatTensorType from skl2onnx import to_onnx  model_onnx = to_onnx(     model,     initial_types=[('input', FloatTensorType([None, X.shape[1]]))],     target_opset={'ai.onnx.ml': 3, 'ai.onnx': 15, '': 15} )  with open(\"isolation_forest.onnx\", \"wb\") as f:     f.write(model_onnx.SerializeToString()) In\u00a0[23]: Copied! <pre>import numpy as np\nimport onnxruntime as rt\n\nfrom streampipes.functions.broker.broker_handler import get_broker_description\nfrom streampipes.functions.streampipes_function import StreamPipesFunction\nfrom streampipes.functions.utils.data_stream_generator import create_data_stream, RuntimeType\nfrom streampipes.functions.utils.function_context import FunctionContext\nfrom streampipes.model.resource import FunctionDefinition, DataStream\n\nfrom typing import Dict, Any, List\n\n\nclass ONNXFunction(StreamPipesFunction):\n\n    def __init__(self, feature_names: list[str], input_stream: DataStream):\n        output_stream = create_data_stream(\n            name=\"flowrate-prediction\",\n            attributes={\n                \"is_anomaly\": RuntimeType.BOOLEAN.value\n            },\n            broker=get_broker_description(input_stream)\n        )\n\n        function_definition = FunctionDefinition(\n            consumed_streams=[input_stream.element_id]\n        ).add_output_data_stream(output_stream)\n\n        self.feature_names = feature_names\n        self.input_name = None\n        self.output_name = None\n        self.session = None\n\n        super().__init__(function_definition=function_definition)\n\n    def onServiceStarted(self, context: FunctionContext) -&gt; None:\n        self.session = rt.InferenceSession(\n            path_or_bytes=\"isolation_forest.onnx\",\n            providers=rt.get_available_providers(),\n        )\n        self.input_name = self.session.get_inputs()[0].name\n        self.output_name = self.session.get_outputs()[0].name\n\n    def onEvent(self, event: Dict[str, Any], streamId: str) -&gt; None:\n        feature_vector = []\n        for feature in self.feature_names:\n            feature_vector.append(event[feature])\n\n        prediction = self.session.run(\n            [self.output_name],\n            {self.input_name: np.expand_dims(np.array(feature_vector), axis=0).astype(\"float32\")}\n        )[0]\n\n        output = {\n            \"is_anomaly\": int(prediction[0]) == -1\n        }\n\n        self.add_output(\n            stream_id=self.function_definition.get_output_stream_ids()[0],\n            event=output\n        )\n\n    def onServiceStopped(self) -&gt; None:\n        pass\n</pre> import numpy as np import onnxruntime as rt  from streampipes.functions.broker.broker_handler import get_broker_description from streampipes.functions.streampipes_function import StreamPipesFunction from streampipes.functions.utils.data_stream_generator import create_data_stream, RuntimeType from streampipes.functions.utils.function_context import FunctionContext from streampipes.model.resource import FunctionDefinition, DataStream  from typing import Dict, Any, List   class ONNXFunction(StreamPipesFunction):      def __init__(self, feature_names: list[str], input_stream: DataStream):         output_stream = create_data_stream(             name=\"flowrate-prediction\",             attributes={                 \"is_anomaly\": RuntimeType.BOOLEAN.value             },             broker=get_broker_description(input_stream)         )          function_definition = FunctionDefinition(             consumed_streams=[input_stream.element_id]         ).add_output_data_stream(output_stream)          self.feature_names = feature_names         self.input_name = None         self.output_name = None         self.session = None          super().__init__(function_definition=function_definition)      def onServiceStarted(self, context: FunctionContext) -&gt; None:         self.session = rt.InferenceSession(             path_or_bytes=\"isolation_forest.onnx\",             providers=rt.get_available_providers(),         )         self.input_name = self.session.get_inputs()[0].name         self.output_name = self.session.get_outputs()[0].name      def onEvent(self, event: Dict[str, Any], streamId: str) -&gt; None:         feature_vector = []         for feature in self.feature_names:             feature_vector.append(event[feature])          prediction = self.session.run(             [self.output_name],             {self.input_name: np.expand_dims(np.array(feature_vector), axis=0).astype(\"float32\")}         )[0]          output = {             \"is_anomaly\": int(prediction[0]) == -1         }          self.add_output(             stream_id=self.function_definition.get_output_stream_ids()[0],             event=output         )      def onServiceStopped(self) -&gt; None:         pass <p>Let's dive a little deeper into the different parts of the function</p> <ul> <li><p><code>__init__</code>: First, we need to take care about the data stream that is required to send the predictions from our function to StreamPipes. Thus, we create a dedicated output data stream which we need to provide with the attributes our event will consist of (a timestamp attribute is always added automatically). This output data stream needs to be registered at the function definition which is to be passed to the parent class. Lastly, we need to define some instance variables that are mainly required for the ONNX runtime.</p> </li> <li><p><code>onServiceStarted</code>: Here we prepare the ONNX runtime session by creating an <code>InferenceSession</code> and retrieving the corresponding configuration parameters.</p> </li> <li><p><code>onEvent</code>: Following the parameter names specified by <code>self.feature_names</code>, we extract all feature values from the current event. Subsequently, the corresponding feature vector is transmitted to the ONNX runtime session. The resulting prediction is then converted into our output event, where a value of <code>-1</code> signifies an anomaly. Finally, the generated output event is forwarded to StreamPipes.</p> </li> </ul> <p>Having the function code in place, we can start the function with the following:</p> In\u00a0[25]: Copied! <pre>from streampipes.functions.registration import Registration\nfrom streampipes.functions.function_handler import FunctionHandler\n\nstream = [\n    stream\n    for stream\n    in client.dataStreamApi.all()\n    if stream.name == \"flow-rate\"\n][0]\n\nfunction = ONNXFunction(\n    feature_names=[\"volume_flow\"],\n    input_stream=stream\n)\n\nregistration = Registration()\nregistration.register(function)\nfunction_handler = FunctionHandler(registration, client)\nfunction_handler.initializeFunctions()\n</pre> from streampipes.functions.registration import Registration from streampipes.functions.function_handler import FunctionHandler  stream = [     stream     for stream     in client.dataStreamApi.all()     if stream.name == \"flow-rate\" ][0]  function = ONNXFunction(     feature_names=[\"volume_flow\"],     input_stream=stream )  registration = Registration() registration.register(function) function_handler = FunctionHandler(registration, client) function_handler.initializeFunctions() <pre>2024-03-26 12:39:50,443 - streampipes.endpoint.endpoint - [INFO] - [endpoint.py:164] [_make_request] - Successfully retrieved all resources.\n2024-03-26 12:39:50,502 - streampipes.functions.function_handler - [INFO] - [function_handler.py:76] [initializeFunctions] - The data stream could not be created.\n2024-03-26 12:39:50,503 - streampipes.functions.function_handler - [INFO] - [function_handler.py:78] [initializeFunctions] - This is due to the fact that this data stream already exists. Continuing with the existing data stream.\n2024-03-26 12:39:50,503 - streampipes.functions.function_handler - [INFO] - [function_handler.py:84] [initializeFunctions] - Using output data stream 'sp:spdatastream:flowrate-prediction' for function '7c06fa31-9534-4f91-9c50-b7a3607ec3dc'\n2024-03-26 12:39:50,548 - streampipes.endpoint.endpoint - [INFO] - [endpoint.py:164] [_make_request] - Successfully retrieved all resources.\n2024-03-26 12:39:50,549 - streampipes.functions.function_handler - [INFO] - [function_handler.py:100] [initializeFunctions] - Using KafkaConsumer for ONNXFunction\n</pre> <p>We can now access the live values of the prediction in the StreamPipes UI, e.g., in the pipeline editor.</p> <p></p> <p>That's already it. We hope this tutorial serves as an illustration how ML models can be utilized in StreamPipes with the help of ONNX.</p> <p>How do you like this tutorial? We hope you like it and would love to receive some feedback from you. Just go to our GitHub discussion page and let us know your impression. We'll read and react to them all, we promise!</p>"},{"location":"tutorials/5-applying-interoperable-machine-learning-in-streampipes/#Applying-Interoperable-Machine-Learning-in-StreamPipes","title":"Applying Interoperable Machine Learning in StreamPipes\u00b6","text":"<p>The last tutorial (Using Online Machine Learning on a StreamPipes data stream) demonstrated how patterns in streaming data can be learned online. In contrast, this tutorial demonstrates how one can apply a pre-trained machine learning (ML) model to a StreamPipes data stream making use of ONNX. We will show how StreamPipes can be used for both: extracting historical data for training purposes and using model inference on live data with a pre-trained model.</p>"},{"location":"tutorials/5-applying-interoperable-machine-learning-in-streampipes/#Preparation","title":"Preparation\u00b6","text":"<p>The following lines configure the client and establish a connection to the StreamPipes instance. If you're not familiar with it or anything is unclear, please have a look at our first tutorial.</p>"},{"location":"tutorials/5-applying-interoperable-machine-learning-in-streampipes/#Machine-Learning-Use-Case","title":"Machine Learning Use Case\u00b6","text":"<p>In this tutorial, we will use data generated by the Machine Data Simulator adapter. More specifically, we will focus on the <code>flowrate</code> data, which consists of various sensor values coming from a water pipe system. Our goal is keep an eye on the parameter <code>volume_flow</code>, which represents the current volume flow in cubic meters/second. For this parameter, we want to detect anomalies that could indicate problems such as leaks, blockages, etc.</p> <p>To get the concerned data, we simply need to create an instance of the machine data simulator and persist the data in the data lake:</p> <p></p> <p>If you choose to perform the model training step yourself, you will need to wait approximately 15 minutes for enough data to be available for model training. If you want to speed this up, you can configure a lower wait time when creating the adapter. Please be aware that this also influences the inference scenario.</p>"},{"location":"tutorials/5-applying-interoperable-machine-learning-in-streampipes/#Model-Training-with-Historic-Data","title":"Model Training with Historic Data\u00b6","text":"<p>As said above, the aim of our model is to detect anomalies of the <code>volume_flow</code> parameter. For this task, we will use Isolation Forests. Please note that the focus of the tutorial is not on training the model, so please be patient even though the training is very simplified and lacks important preparation steps such as standardization.</p> <p>As a first step, lets query the <code>flowrate</code> data from the StreamPipes data lake and extract the values of <code>volume_flow</code> as a feature:</p>"},{"location":"tutorials/5-applying-interoperable-machine-learning-in-streampipes/#Model-Inference-with-Live-Data","title":"Model Inference with Live Data\u00b6","text":"<p>Utilizing a pre-trained model within StreamPipes becomes seamless with the ONNX interoperability standard, enabling effortless application of your existing model on live data streams.</p> <p>Interacting with live data from StreamPipes is facilitated through StreamPipes functions. Below, we'll create a Python StreamPipes function that leverages an ONNX model to generate predictions for each incoming event, making the results accessible as a data stream within StreamPipes for subsequent steps.</p> <p>So let's create an <code>ONNXFunction</code> that is capable of applying a model in ONNX representation to a StreamPipes data stream. If you'd like to read more details about how functions are defined, refer to our third tutorial.</p>"}]}