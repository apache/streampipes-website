<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Tutorial: Data Processors · StreamPipes</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="&lt;p&gt;In this tutorial, we will add a new data processor using the Apache Flink wrapper.&lt;/p&gt;
"/><meta name="docsearch:version" content="0.63.0"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Tutorial: Data Processors · StreamPipes"/><meta property="og:type" content="website"/><meta property="og:url" content="https://docs.streampipes.org/docs/"/><meta property="og:description" content="&lt;p&gt;In this tutorial, we will add a new data processor using the Apache Flink wrapper.&lt;/p&gt;
"/><meta property="og:image" content="https://docs.streampipes.org/docs/img/favicon.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://docs.streampipes.org/docs/img/docusaurus.png"/><link rel="shortcut icon" href="/docs/img/favicon.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css"/><link rel="alternate" type="application/atom+xml" href="https://docs.streampipes.org/docs/blog/atom.xml" title="StreamPipes Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://docs.streampipes.org/docs/blog/feed.xml" title="StreamPipes Blog RSS Feed"/><link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/slick-carousel/1.9.0/slick.min.css"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/slick-carousel/1.9.0/slick-theme.min.css"/><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto"/><link rel="stylesheet" href="/docs/css/admonition.css"/><link rel="stylesheet" href="/docs/css/custom.css"/><link rel="stylesheet" href="/docs/css/code-block-buttons.css"/><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css"/><script type="text/javascript" src="https://code.jquery.com/jquery-3.3.1.min.js"></script><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/slick-carousel/1.9.0/slick.min.js"></script><script type="text/javascript" src="/docs/js/custom.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script><script type="text/javascript" src="/docs/js/code-block-buttons.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.1.14/dist/vanilla-back-to-top.min.js"></script><script>
        document.addEventListener('DOMContentLoaded', function() {
          addBackToTop(
            {"zIndex":100}
          )
        });
        </script><link rel="stylesheet" href="/docs/css/prism.css"/><link rel="stylesheet" href="/docs/css/main.css"/><script src="/docs/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/docs/"><img class="logo" src="/docs/img/sp-logo-color-docs.png" alt="StreamPipes"/></a><a href="/docs/versions"><h3>0.63.0</h3></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/docs/docs/0.63.0/user-guide-introduction" target="_self">User Guide</a></li><li class="siteNavGroupActive"><a href="/docs/docs/0.63.0/dev-guide-introduction" target="_self">Developer Guide</a></li><li class=""><a href="/docs/docs/0.63.0/pipeline-elements" target="_self">Pipeline Elements</a></li><li class=""><a href="/docs/docs/0.63.0/faq-common-problems" target="_self">FAQ</a></li><li class=""><a href="/docs/blog/" target="_self">Blog</a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><i></i></div><h2><i>›</i><span>Tutorials</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Basics</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/docs/0.63.0/dev-guide-introduction">Introduction</a></li><li class="navListItem"><a class="navItem" href="/docs/docs/0.63.0/dev-guide-architecture">Architecture</a></li><li class="navListItem"><a class="navItem" href="/docs/docs/0.63.0/dev-guide-development-environment">Development Environment</a></li><li class="navListItem"><a class="navItem" href="/docs/docs/0.63.0/dev-guide-archetype">Start Developing</a></li><li class="navListItem"><a class="navItem" href="/docs/docs/0.63.0/dev-guide-migration">Migration Guide</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Tutorials</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/docs/0.63.0/dev-guide-tutorial-sources">Tutorial: Data Sources</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/docs/0.63.0/dev-guide-tutorial-processors">Tutorial: Data Processors</a></li><li class="navListItem"><a class="navItem" href="/docs/docs/0.63.0/dev-guide-tutorial-sinks">Tutorial: Data Sinks</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">SDK Reference</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/docs/0.63.0/dev-guide-sdk-guide-sources">SDK Guide Sources</a></li><li class="navListItem"><a class="navItem" href="/docs/docs/0.63.0/dev-guide-sdk-guide-processors">SDK Guide: Data Processors</a></li><li class="navListItem"><a class="navItem" href="/docs/docs/0.63.0/dev-guide-sdk-guide-sinks">SDK Guide: Data Sinks</a></li><li class="navListItem"><a class="navItem" href="/docs/docs/0.63.0/dev-guide-stream-requirements">Stream Requirements</a></li><li class="navListItem"><a class="navItem" href="/docs/docs/0.63.0/dev-guide-static-properties">Static Properties</a></li><li class="navListItem"><a class="navItem" href="/docs/docs/0.63.0/dev-guide-output-strategies">Output Strategies</a></li><li class="navListItem"><a class="navItem" href="/docs/docs/0.63.0/dev-guide-event-model">Event Model</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Configuration</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/docs/0.63.0/dev-guide-ssl">Use SSL</a></li><li class="navListItem"><a class="navItem" href="/docs/docs/0.63.0/dev-guide-configuration">Configuration</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              const headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                if (event.target.tagName === 'A') {
                  document.body.classList.remove('tocActive');
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 class="postHeaderTitle">Tutorial: Data Processors</h1></header><article><div><span><p>In this tutorial, we will add a new data processor using the Apache Flink wrapper.</p>
<p>From an architectural point of view, we will create a self-contained service that includes the description of the data processor and a Flink-compatible implementation.
Once a pipeline is started that uses this data processor, the implementation is submitted to an Apache Flink cluster.</p>
<h2><a class="anchor" aria-hidden="true" id="objective"></a><a href="#objective" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Objective</h2>
<p>We are going to create a new data processor that realized a simple geofencing algorithm - we detect vehicles that enter a specified radius around a user-defined location.
This pipeline element will be a generic element that works with any event stream that provides geospatial coordinates in form of a latitude/longitude pair.</p>
<p>The algorithm outputs every location event once the position has entered the geofence.</p>
<div class="admonition note">
<div class="admonition-title">Note</div>
<p>The implementation in this tutorial is pretty simple - our processor will fire an event every time the GPS location is inside the geofence.
       In a real-world application, you would probably want to define a pattern that recognizes the _first_ event a vehicle enters the geofence.<br/>
       This can be easily done using a CEP library, e.g., Apache Flink CEP.</p>
</div>
<h2><a class="anchor" aria-hidden="true" id="project-setup"></a><a href="#project-setup" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Project setup</h2>
<p>To create new projects from scratch, several Maven archetypes exist to start developing.
Enter the following command to create a new project based on the StreamPipes <code>Processors-Flink</code> archetype:</p>
<pre><code class="hljs">mvn archetype:generate <span class="hljs-attribute">-DarchetypeGroupId</span>=org.streampipes \
<span class="hljs-attribute">-DarchetypeArtifactId</span>=streampipes-archetype-pe-processors-flink <span class="hljs-attribute">-DarchetypeVersion</span>=0.63.0 \
<span class="hljs-attribute">-DgroupId</span>=org.streampipes.tutorial <span class="hljs-attribute">-DartifactId</span>=geofence-tutorial <span class="hljs-attribute">-DclassNamePrefix</span>=Geofencing <span class="hljs-attribute">-DpackageName</span>=geofencing
</code></pre>
<p>Once you've imported the generated project, the project structure should look as follows:</p>
<p><img src="/docs/img/tutorial-processors/project-structure-processor.PNG" alt="Project Structure Data Processor"></p>
<div class="admonition tip">
<div class="admonition-title">Tip</div>
<p>Besides the basic project skeleton, the sample project also includes an example Dockerfile you can use to package your application into a Docker container.</p>
</div>
<p>Now you're ready to create your first data processor for StreamPipes!</p>
<h2><a class="anchor" aria-hidden="true" id="adding-data-processor-requirements"></a><a href="#adding-data-processor-requirements" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Adding data processor requirements</h2>
<p>First, we will add a new stream requirement.
Open the class <code>GeofencingController</code> which should look as follows:</p>
<pre><code class="hljs css language-java"><span class="hljs-keyword">package</span> org.streampipes.tutorial.pe.processor.geofencing;

<span class="hljs-keyword">import</span> org.streampipes.tutorial.config.Config;

<span class="hljs-keyword">import</span> org.streampipes.model.DataProcessorType;
<span class="hljs-keyword">import</span> org.streampipes.model.graph.DataProcessorDescription;
<span class="hljs-keyword">import</span> org.streampipes.model.graph.DataProcessorInvocation;
<span class="hljs-keyword">import</span> org.streampipes.sdk.builder.ProcessingElementBuilder;
<span class="hljs-keyword">import</span> org.streampipes.sdk.builder.StreamRequirementsBuilder;
<span class="hljs-keyword">import</span> org.streampipes.sdk.extractor.ProcessingElementParameterExtractor;
<span class="hljs-keyword">import</span> org.streampipes.sdk.helpers.EpRequirements;
<span class="hljs-keyword">import</span> org.streampipes.sdk.helpers.Labels;
<span class="hljs-keyword">import</span> org.streampipes.sdk.helpers.OutputStrategies;
<span class="hljs-keyword">import</span> org.streampipes.sdk.helpers.SupportedFormats;
<span class="hljs-keyword">import</span> org.streampipes.sdk.helpers.SupportedProtocols;
<span class="hljs-keyword">import</span> org.streampipes.wrapper.flink.FlinkDataProcessorDeclarer;
<span class="hljs-keyword">import</span> org.streampipes.wrapper.flink.FlinkDataProcessorRuntime;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GeofencingController</span> <span class="hljs-keyword">extends</span>
                <span class="hljs-title">FlinkDataProcessorDeclarer</span>&lt;<span class="hljs-title">GeofencingParameters</span>&gt; </span>{

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String EXAMPLE_KEY = <span class="hljs-string">"example-key"</span>;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> DataProcessorDescription <span class="hljs-title">declareModel</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> ProcessingElementBuilder.create(<span class="hljs-string">"org.streampipes.tutorial-geofencing"</span>)
                        .category(DataProcessorType.ENRICH)
                        .withAssets(Assets.DOCUMENTATION, Assets.ICON)
                        .withLocales(Locales.EN)
                        .requiredStream(StreamRequirementsBuilder
                            .create()
                            .requiredProperty(EpRequirements.anyProperty())
                            .build())
                        .outputStrategy(OutputStrategies.keep())
                        .requiredTextParameter(Labels.from(EXAMPLE_KEY, <span class="hljs-string">"Example Text Parameter"</span>, <span class="hljs-string">"Example "</span> +
                <span class="hljs-string">"Text Parameter Description"</span>))
                        .build();
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> FlinkDataProcessorRuntime&lt;GeofencingParameters&gt; <span class="hljs-title">getRuntime</span><span class="hljs-params">(DataProcessorInvocation
                graph, ProcessingElementParameterExtractor extractor)</span> </span>{

        String exampleString = extractor.singleValueParameter(EXAMPLE_KEY, String<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

        GeofencingParameters params = <span class="hljs-keyword">new</span> GeofencingParameters(graph, exampleString);

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> GeofencingProgram(params, Config.INSTANCE.getDebug());
    }

}

</code></pre>
<p>In this class, we need to implement two methods: The <code>declareModel</code> method is used to define abstract stream requirements such as event properties that must be present in any input stream that is later connected to the element using the StreamPipes UI.
The second method, <code>getRuntime</code> is used to create and deploy the parameterized Flink program once a pipeline using this element is started.</p>
<p>Similar to data sources, the SDK provides a builder class to generate the description for data processors.
Delete the content within the <code>declareModel</code> method and add the following lines to the <code>declareModel</code> method:</p>
<pre><code class="hljs css language-java"><span class="hljs-keyword">return</span> ProcessingElementBuilder.create(<span class="hljs-string">"org.streampipes.tutorial.geofencing"</span>, <span class="hljs-string">"Geofencing"</span>, <span class="hljs-string">"A simple geofencing data processor "</span> +
            <span class="hljs-string">"using the Apache Flink wrapper"</span>)
</code></pre>
<p>This creates a new data processor with the ID, title and description assigned to the element builder.
Next, we add some <em>stream requirements</em> to the description. As we'd like to develop a generic pipeline element that works with any event that provides a lat/lng pair, we define two stream requirements as stated below:</p>
<pre><code class="hljs css language-java">.requiredStream(StreamRequirementsBuilder
    .create()
    .requiredPropertyWithUnaryMapping(EpRequirements.domainPropertyReq(Geo.lat),
            Labels.from(<span class="hljs-string">"latitude-field"</span>, <span class="hljs-string">"Latitude"</span>, <span class="hljs-string">"The event "</span> +
            <span class="hljs-string">"property containing the latitude value"</span>), PropertyScope.MEASUREMENT_PROPERTY)
    .requiredPropertyWithUnaryMapping(EpRequirements.domainPropertyReq(Geo.lng),
            Labels.from(<span class="hljs-string">"longitude-field"</span>, <span class="hljs-string">"Longitude"</span>, <span class="hljs-string">"The event "</span> +
                    <span class="hljs-string">"property containing the longitude value"</span>), PropertyScope.MEASUREMENT_PROPERTY)
    .build())
</code></pre>
<p>The first line, <code>.requiredStream()</code> defines that we want a data processor with exactly one input stream. Adding more stream requirements would create elements with multiple input connectors in StreamPipes.
Stream requirements can be assigned by using the <code>StreamRequirementsBuilder</code> class.
In our example, we define two requirements, so-called <em>domain property requirements</em>. In contrast to <em>data type requirements</em> where we'd expect an event property with a field of a specific data type (e.g., float), domain property requirements expect a specific domain property, e.g., from a vocabulary such as the WGS84 Geo vocab.</p>
<p>Once a pipeline is deployed, we are interested in the actual field (and its field name) that contains the latitude and longitude values.
In some cases, there might me more than one field that satisfies a property requirement and we would like users to select the property the geofencing component should operate on.
Therefore, our example uses the method <code>requiredPropertyWithUnaryMapping</code>, which will map a requirement to a real event property of an input stream and  let the user choose the appropriate field in the StreamPipes UI when pipelines are defined.</p>
<p>Finally, the <code>PropertyScope</code> indicates that the required property is a measurement value (in contrast to a dimension value). This allows us later to provide improved user guidance in the pipeline editor.</p>
<p>Besides requirements, users should be able to define the center coordinate of the Geofence and the size of the fence defined as a radius around the center in meters.
The radius can be defined by adding a simple required text field to the description:</p>
<pre><code class="hljs css language-java">.requiredIntegerParameter(<span class="hljs-string">"radius"</span>, <span class="hljs-string">"Geofence Size"</span>, <span class="hljs-string">"The size of the circular geofence in meters."</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1000</span>, <span class="hljs-number">1</span>)
</code></pre>
<p>Similar to mapping properties, text parameters have an internalId (radius), a label and a description.
In addition, we can assign a <em>value specification</em> to the parameter indicating the value range we support.
Our example supports a radius value between 0 and 1000 with a granularity of 1.
In the StreamPipes UI, a required text parameter is rendered as a text input field, in case we provide an optional value specification, a slider input is automatically generated.</p>
<p>Such user-defined parameters are called <em>static properties</em>. There are many different types of static properties (see the <a href="dev-guide-sdk-guide-processors#docsNav">Processor SDK</a> for an overview).</p>
<p>One example are <em>DomainProperties</em> we use for defining the center of the geofence.
Our data processor requires a lat/lng pair that marks the center of the geofence.
However, letting users directly input latitude and longitude coordinates wouldn't be very user-friendly.
Therefore, we can link required text parameters to <em>ontology concepts</em>. By understanding the required input, the StreamPipes UI is able to determine which user interface works best for a specific concept.</p>
<p>Add the following line to the <code>declareModel</code> method:</p>
<pre><code class="hljs css language-java">.requiredOntologyConcept(Labels.from(<span class="hljs-string">"location"</span>, <span class="hljs-string">"Geofence Center"</span>, <span class="hljs-string">"Provide the coordinate of the "</span> +
    <span class="hljs-string">"geofence center"</span>), OntologyProperties.mandatory(Geo.lat), OntologyProperties.mandatory(Geo.lng))

</code></pre>
<p>We've now defined that we would like to receive an instance that provides a latitude and a longitude coordinate.
Users can input these values either manually, or they can look up <em>domain knowledge</em>, i.e., knowledge stored isolated from the stream definition.</p>
<p>Finally, we need to define technical requirements of the data processor, called <em>groundings</em>.
StreamPipes supports various runtime data formats (e.g., JSON or Thrift) and various protocols (e.g., Kafka or JMS).
Each component defines supports formats and protocol separately.
For our example, we'd like to support JSON-based messages and Kafka as input and output broker protocol, so append the following:</p>
<pre><code class="hljs css language-java">.supportedProtocols(SupportedProtocols.kafka())
.supportedFormats(SupportedFormats.jsonFormat())
.build();
</code></pre>
<p>Now we need to define the output of our Geofencing pipeline element.
As explained in the first section, the element should fire every time some geo-located entity arrives within the defined geofence.
Therefore, the processor outputs the same schema as it receives as an input.
Although we don't know the exact input right now as it depends on the stream users connect in StreamPipes when creating pipelines, we can define an <em>output strategy</em> as follows:</p>
<pre><code class="hljs css language-java">.outputStrategy(OutputStrategies.keep())
</code></pre>
<p>This defines a <em>KeepOutputStrategy</em>, i.e., the input event schema is not modified by the processor.
There are many more output strategies you can define depending on the functionality you desire, e.g., <em>AppendOutput</em> for defining a processor that enriches events or <em>CustomOutput</em> in case you would like users to select the output by themselves.</p>
<p>That's it! We've now defined input requirements, required user input, technical requirements concerned with data format and protocol and an output strategy.
In the next section, you will learn how to extract these parameters once the pipeline element is invoked after a pipeline was created.</p>
<h2><a class="anchor" aria-hidden="true" id="pipeline-element-invocation"></a><a href="#pipeline-element-invocation" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Pipeline element invocation</h2>
<p>Once users start a pipeline that uses our geofencing component, the <em>getRuntime</em> method in our class is called. The class <code>DataSinkInovcation</code> includes a graph that contains information on the configuration parameters a users has selected in the pipeline editor and information on the acutal streams that are connected to the pipeline element.</p>
<p>Before we explain in more detail how to extract these values from the processor invocation, we need to adapt a little helper class.
Open the file <code>GeofencingParameters</code> and modify it as follows:</p>
<pre><code class="hljs css language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GeofencingParameters</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">EventProcessorBindingParams</span> </span>{

  <span class="hljs-keyword">private</span> String latitudeFieldName;
  <span class="hljs-keyword">private</span> String longitudeFieldName;

  <span class="hljs-keyword">private</span> Float centerLatitude;
  <span class="hljs-keyword">private</span> Float centerLongitude;

  <span class="hljs-keyword">private</span> Integer radius;

  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GeofencingParameters</span><span class="hljs-params">(DataProcessorInvocation graph, String latitudeFieldName, String longitudeFieldName,
                              Float centerLatitude, Float centerLongitude, Integer radius)</span> </span>{
    <span class="hljs-keyword">super</span>(graph);
    <span class="hljs-keyword">this</span>.latitudeFieldName = latitudeFieldName;
    <span class="hljs-keyword">this</span>.longitudeFieldName = longitudeFieldName;
    <span class="hljs-keyword">this</span>.centerLatitude = centerLatitude;
    <span class="hljs-keyword">this</span>.centerLongitude = centerLongitude;
    <span class="hljs-keyword">this</span>.radius = radius;
  }

  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getLatitudeFieldName</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> latitudeFieldName;
  }

  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getLongitudeFieldName</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> longitudeFieldName;
  }

  <span class="hljs-function"><span class="hljs-keyword">public</span> Float <span class="hljs-title">getCenterLatitude</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> centerLatitude;
  }

  <span class="hljs-function"><span class="hljs-keyword">public</span> Float <span class="hljs-title">getCenterLongitude</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> centerLongitude;
  }

  <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getRadius</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> radius;
  }
</code></pre>
<p>This simple Pojo class will later serve to store user-defined parameters in a single object.</p>
<p>Now we go back to the controller class and extract these values from the invocation object.</p>
<p>The <code>ProessingElementParameterExtractor</code>  provides convenience methods to extract the relevant information from the <code>DataProcessorInvocation</code> object.</p>
<p>Next, we are interested in the fields of the input event stream that contains the latitude and longitude value we would like to compute against the geofence center location as follows:</p>
<pre><code class="hljs css language-java">String latitudeFieldName = extractor.mappingPropertyValue(<span class="hljs-string">"latitude-field"</span>);
String longitudeFieldName = extractor.mappingPropertyValue(<span class="hljs-string">"longitude-field"</span>);
</code></pre>
<p>We use the same <code>internalId</code> we've used to define the mapping property requirements in the <code>declareModel</code> method.</p>
<p>Next, for extracting the geofence center coordinates, we use the following statements:</p>
<pre><code class="hljs css language-java">Float centerLatitude = extractor.supportedOntologyPropertyValue(<span class="hljs-string">"location"</span>, Geo.lat, Float<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
Float centerLongitude = extractor.supportedOntologyPropertyValue(<span class="hljs-string">"location"</span>, Geo.lng, Float<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
</code></pre>
<p>The radius value can be extracted as follows:</p>
<pre><code class="hljs css language-java">Integer radius = extractor.singleValueParameter(<span class="hljs-string">"radius"</span>, Integer<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
</code></pre>
<p>Now we can create a new instance of our previously created parameter class:</p>
<pre><code class="hljs css language-java">GeofencingParameters params = <span class="hljs-keyword">new</span> GeofencingParameters(dataProcessorInvocation, latitudeFieldName,
            longitudeFieldName, centerLatitude, centerLongitude, radius);
</code></pre>
<p>Finally, return an instance of the class <code>GeofencingProgram</code>:</p>
<pre><code class="hljs css language-java"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> GeofencingProgram(params, <span class="hljs-keyword">true</span>);
</code></pre>
<div class="admonition tip">
<div class="admonition-title">Info</div>
<p>The line above uses the Flink MiniCluster to start the Flink program for debugging purposes.
       Before you build the project and use it in a real environment, replace the line as follows, which triggers cluster execution:
       <code>return new GeofencingProgram(params, new FlinkDeploymentConfig(Config.JAR_FILE, Config.INSTANCE.getFlinkHost(), Config.INSTANCE.getFlinkPort())</code></p>
</div>
<p>Great! That's all we need to describe a data processor for usage in StreamPipes. Your controller class should look as follows:</p>
<pre><code class="hljs css language-java"><span class="hljs-keyword">import</span> org.streampipes.model.graph.DataProcessorDescription;
<span class="hljs-keyword">import</span> org.streampipes.model.graph.DataProcessorInvocation;
<span class="hljs-keyword">import</span> org.streampipes.model.schema.PropertyScope;
<span class="hljs-keyword">import</span> org.streampipes.sdk.builder.ProcessingElementBuilder;
<span class="hljs-keyword">import</span> org.streampipes.sdk.builder.StreamRequirementsBuilder;
<span class="hljs-keyword">import</span> org.streampipes.sdk.extractor.ProcessingElementParameterExtractor;
<span class="hljs-keyword">import</span> org.streampipes.sdk.helpers.EpRequirements;
<span class="hljs-keyword">import</span> org.streampipes.sdk.helpers.Labels;
<span class="hljs-keyword">import</span> org.streampipes.sdk.helpers.OntologyProperties;
<span class="hljs-keyword">import</span> org.streampipes.sdk.helpers.OutputStrategies;
<span class="hljs-keyword">import</span> org.streampipes.sdk.helpers.SupportedFormats;
<span class="hljs-keyword">import</span> org.streampipes.sdk.helpers.SupportedProtocols;
<span class="hljs-keyword">import</span> org.streampipes.vocabulary.Geo;
<span class="hljs-keyword">import</span> org.streampipes.wrapper.flink.FlinkDataProcessorDeclarer;
<span class="hljs-keyword">import</span> org.streampipes.wrapper.flink.FlinkDataProcessorRuntime;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GeofencingController</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">FlinkDataProcessorDeclarer</span>&lt;<span class="hljs-title">GeofencingParameters</span>&gt; </span>{

  <span class="hljs-meta">@Override</span>
  <span class="hljs-function"><span class="hljs-keyword">protected</span> FlinkDataProcessorRuntime&lt;GeofencingParameters&gt; <span class="hljs-title">getRuntime</span><span class="hljs-params">(DataProcessorInvocation dataProcessorInvocation)</span> </span>{
    ProcessingElementParameterExtractor extractor = ProcessingElementParameterExtractor.from(dataProcessorInvocation);

    String latitudeFieldName = extractor.mappingPropertyValue(<span class="hljs-string">"latitude-field"</span>);
    String longitudeFieldName = extractor.mappingPropertyValue(<span class="hljs-string">"longitude-field"</span>);

    Float centerLatitude = extractor.supportedOntologyPropertyValue(<span class="hljs-string">"location"</span>, Geo.lat, Float<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
    Float centerLongitude = extractor.supportedOntologyPropertyValue(<span class="hljs-string">"location"</span>, Geo.lng, Float<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    Integer radius = extractor.singleValueParameter(<span class="hljs-string">"radius"</span>, Integer<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    GeofencingParameters params = <span class="hljs-keyword">new</span> GeofencingParameters(dataProcessorInvocation, latitudeFieldName,
            longitudeFieldName, centerLatitude, centerLongitude, radius);

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> GeofencingProgram(params);
  }

  <span class="hljs-meta">@Override</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> DataProcessorDescription <span class="hljs-title">declareModel</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> ProcessingElementBuilder.create(<span class="hljs-string">"geofencing-flink"</span>, <span class="hljs-string">"Geofencing"</span>, <span class="hljs-string">"A simple geofencing data processor "</span> +
            <span class="hljs-string">"using the Apache Flink wrapper"</span>)
            .requiredStream(StreamRequirementsBuilder
                    .create()
                    .requiredPropertyWithUnaryMapping(EpRequirements.domainPropertyReq(Geo.lat),
                            Labels.from(<span class="hljs-string">"latitude-field"</span>, <span class="hljs-string">"Latitude"</span>, <span class="hljs-string">"The event "</span> +
                            <span class="hljs-string">"property containing the latitude value"</span>), PropertyScope.MEASUREMENT_PROPERTY)
                    .requiredPropertyWithUnaryMapping(EpRequirements.domainPropertyReq(Geo.lng),
                            Labels.from(<span class="hljs-string">"longitude-field"</span>, <span class="hljs-string">"Longitude"</span>, <span class="hljs-string">"The event "</span> +
                                    <span class="hljs-string">"property containing the longitude value"</span>), PropertyScope.MEASUREMENT_PROPERTY)
                    .build())
            .requiredIntegerParameter(<span class="hljs-string">"radius"</span>, <span class="hljs-string">"Geofence Size"</span>, <span class="hljs-string">"The size of the circular geofence in meters."</span>,
                    <span class="hljs-number">0</span>, <span class="hljs-number">1000</span>, <span class="hljs-number">1</span>)
            .requiredOntologyConcept(Labels.from(<span class="hljs-string">"location"</span>, <span class="hljs-string">"Geofence Center"</span>, <span class="hljs-string">"Provide the coordinate of the "</span> +
                    <span class="hljs-string">"geofence center"</span>), OntologyProperties.mandatory(Geo.lat), OntologyProperties.mandatory(Geo.lng))
            .supportedProtocols(SupportedProtocols.kafka())
            .supportedFormats(SupportedFormats.jsonFormat())
            .outputStrategy(OutputStrategies.keep())
            .build();
  }
}

</code></pre>
<h2><a class="anchor" aria-hidden="true" id="adding-an-implementation"></a><a href="#adding-an-implementation" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Adding an implementation</h2>
<p>Everything we need to do now is to add an implementation which does not differ from writing an Apache Flink topology.</p>
<p>Open the class <code>GeofencingProcessor.java</code> and add the following piece of code, which realizes the Geofencing functionality:</p>
<pre><code class="hljs css language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GeofencingProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">FlatMapFunction</span>&lt;<span class="hljs-title">Map</span>&lt;<span class="hljs-title">String</span>, <span class="hljs-title">Object</span>&gt;, <span class="hljs-title">Map</span>&lt;<span class="hljs-title">String</span>, <span class="hljs-title">Object</span>&gt;&gt; </span>{

  <span class="hljs-keyword">private</span> String latitudeFieldName;
  <span class="hljs-keyword">private</span> String longitudeFieldName;

  <span class="hljs-keyword">private</span> Float centerLatitude;
  <span class="hljs-keyword">private</span> Float centerLongitude;

  <span class="hljs-keyword">private</span> Integer radius;

  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GeofencingProcessor</span><span class="hljs-params">(String latitudeFieldName, String longitudeFieldName, Float centerLatitude, Float centerLongitude, Integer radius)</span> </span>{
    <span class="hljs-keyword">this</span>.latitudeFieldName = latitudeFieldName;
    <span class="hljs-keyword">this</span>.longitudeFieldName = longitudeFieldName;
    <span class="hljs-keyword">this</span>.centerLatitude = centerLatitude;
    <span class="hljs-keyword">this</span>.centerLongitude = centerLongitude;
    <span class="hljs-keyword">this</span>.radius = radius;
  }

  <span class="hljs-meta">@Override</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">flatMap</span><span class="hljs-params">(Event in, Collector&lt;Event&gt; out)</span> <span class="hljs-keyword">throws</span> Exception </span>{
    Float latitude = in.getFieldBySelector(latitudeFieldName).getAsPrimitive().getAsFloat();
    Float longitude = in.getFieldBySelector(longitudeFieldName).getAsPrimitive().getAsFloat();

    Float distance = distFrom(latitude, longitude, centerLatitude, centerLongitude);

    <span class="hljs-keyword">if</span> (distance &lt;= radius) {
      out.collect(in);
    }
  }

  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Float <span class="hljs-title">distFrom</span><span class="hljs-params">(<span class="hljs-keyword">float</span> lat1, <span class="hljs-keyword">float</span> lng1, <span class="hljs-keyword">float</span> lat2, <span class="hljs-keyword">float</span> lng2)</span> </span>{
    <span class="hljs-keyword">double</span> earthRadius = <span class="hljs-number">6371000</span>;
    <span class="hljs-keyword">double</span> dLat = Math.toRadians(lat2-lat1);
    <span class="hljs-keyword">double</span> dLng = Math.toRadians(lng2-lng1);
    <span class="hljs-keyword">double</span> a = Math.sin(dLat/<span class="hljs-number">2</span>) * Math.sin(dLat/<span class="hljs-number">2</span>) +
            Math.cos(Math.toRadians(lat1)) * Math.cos(Math.toRadians(lat2)) *
                    Math.sin(dLng/<span class="hljs-number">2</span>) * Math.sin(dLng/<span class="hljs-number">2</span>);
    <span class="hljs-keyword">double</span> c = <span class="hljs-number">2</span> * Math.atan2(Math.sqrt(a), Math.sqrt(<span class="hljs-number">1</span>-a));
    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">float</span>) (earthRadius * c);
  }

}
</code></pre>
<p>We won't go into details here as this isn't StreamPipes-related code, but in general the class extracts latitude and longitude fields from the input event (which is provided as a map data type) and calculates the distance between the geofence center and these coordinates.
If the distance is below the given radius, the event is forwarded to the next operator.</p>
<p>Finally, we need to connect this program to the Flink topology. StreamPipes automatically adds things like the Kafka consumer and producer, so that you only need to invoke the actual geofencing processor.
Open the file <code>GeofencingProgram</code> and append the following line inside the <code>getApplicationLogic()</code> method:</p>
<pre><code class="hljs css language-java"><span class="hljs-keyword">return</span> dataStreams[<span class="hljs-number">0</span>].flatMap(<span class="hljs-keyword">new</span> GeofencingProcessor(params.getLatitudeFieldName(), params.getLongitudeFieldName(),
    params.getCenterLatitude(), params.getCenterLongitude(), params.getRadius()));
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="preparing-the-container"></a><a href="#preparing-the-container" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Preparing the container</h2>
<p>The final step is to define the deployment type of our new data source. In this tutorial, we will create a so-called <code>StandaloneModelSubmitter</code>.
This client will start an embedded web server that provides the description of our data source and automatically submits the program to the registered Apache Flink cluster.</p>
<p>Go to the class <code>Init</code> that extends <code>StandaloneModelSubmitter</code> and should look as follows:</p>
<pre><code class="hljs css language-java"><span class="hljs-keyword">package</span> org.streampipes.tutorial.main;

<span class="hljs-keyword">import</span> org.streampipes.container.init.DeclarersSingleton;
<span class="hljs-keyword">import</span> org.streampipes.container.standalone.init.StandaloneModelSubmitter;

<span class="hljs-keyword">import</span> org.streampipes.tutorial.config.Config;
<span class="hljs-keyword">import</span> org.streampipes.tutorial.pe.processor.geofencing.GeofencingController;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Init</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StandaloneModelSubmitter</span> </span>{

  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>{
    DeclarersSingleton.getInstance()
            .add(<span class="hljs-keyword">new</span> GeofencingController());

    <span class="hljs-keyword">new</span> Init().init(Config.INSTANCE);

  }
}
</code></pre>
<div class="admonition info">
<div class="admonition-title">Info</div>
<p>In the example above, we make use of a class `Config`.
       This class contains both mandatory and additional configuration parameters required by a pipeline element container.
       These values are stored in the Consul-based key-value store of your StreamPipes installation.
       The SDK guide contains a detailed manual on managing container configurations.
</p>
</div>
<h2><a class="anchor" aria-hidden="true" id="starting-the-container"></a><a href="#starting-the-container" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Starting the container</h2>
<div class="admonition tip">
<div class="admonition-title">Tip</div>
<p>By default, the container registers itself using the hostname later used by the Docker container, leading to a 404 error when you try to access an RDF description.
       For local development, we provide an environment file in the ``development`` folder. You can add your hostname here, which will override settings from the Config class.
       For instance, use the IntelliJ ``EnvFile`` plugin to automatically provide the environment variables upon start.
</p>
</div>
<div class="admonition tip">
<div class="admonition-title">Tip</div>
<p> The default port of all pipeline element containers as defined in the `Config` file is port 8090.
       If you'd like to run mutliple containers at the same time on your development machine, change the port in the environment file.
</p>
</div>
<p>Now we are ready to start our container!</p>
<p>Execute the main method in the class <code>Main</code> we've just created, open a web browser and navigate to <a href="http://localhost:8090">http://localhost:8090</a> (or the port you have assigned in the environment file).</p>
<p>You should see something as follows:</p>
<p><img src="/docs/img/tutorial-processors/pe-overview-flink.PNG" alt="Pipeline Element Container Overview (Flink)"></p>
<p>Click on the link of the data source to see the RDF description of the pipeline element.</p>
<p><img src="/docs/img/tutorial-processors/pe-rdf-geofencing.PNG" alt="Geofencing RDF description"></p>
<p>The container automatically registers itself in the Consul installation of StreamPipes.
To install the just created element, open the StreamPipes UI and follow the manual provided in the <a href="user-guide-installation">user guide</a>.</p>
<h2><a class="anchor" aria-hidden="true" id="read-more"></a><a href="#read-more" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Read more</h2>
<p>Congratulations! You've just created your first data processor for StreamPipes.
There are many more things to explore and data processors can be defined in much more detail using multiple wrappers.
Follow our <a href="dev-guide-sdk-guide-processors">SDK guide</a> to see what's possible!</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/docs/0.63.0/dev-guide-tutorial-sources"><span class="arrow-prev">← </span><span>Tutorial: Data Sources</span></a><a class="docs-next button" href="/docs/docs/0.63.0/dev-guide-tutorial-sinks"><span>Tutorial: Data Sinks</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#objective">Objective</a></li><li><a href="#project-setup">Project setup</a></li><li><a href="#adding-data-processor-requirements">Adding data processor requirements</a></li><li><a href="#pipeline-element-invocation">Pipeline element invocation</a></li><li><a href="#adding-an-implementation">Adding an implementation</a></li><li><a href="#preparing-the-container">Preparing the container</a></li><li><a href="#starting-the-container">Starting the container</a></li><li><a href="#read-more">Read more</a></li></ul></nav></div><div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/docs/" class="nav-home"><img src="/docs/img/sp-logo-color.png" alt="StreamPipes" width="66"/></a><div><h5>Docs</h5><a href="/docs/docs/user-guide-introduction">User Guide</a><a href="/docs/docs/dev-guide-introduction">Developer Guide</a><a href="/docs/docs/faq-common-problems">Frequently Asked Questions</a></div><div><h5>Community</h5><a href="http://stackoverflow.com/questions/tagged/streampipes" target="_blank" rel="noreferrer noopener">Stack Overflow</a><a href="https://twitter.com/streampipes" target="_blank" rel="noreferrer noopener">Twitter</a><a href="https://github.com/apache/incubator-streampipes" target="_blank" rel="noreferrer noopener">Github</a><a href="https://hub.docker.com/u/streampipes" target="_blank" rel="noreferrer noopener">Docker Hub</a></div><div><h5>More</h5><a href="/docs/blog">Blog</a><a href="https://streampipes.apache.org.org">Website</a><a class="github-button" href="https://github.com/apache/incubator-streampipes" data-icon="octicon-star" data-count-href="/streampipes/streampipes/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Star</a></div></section><section class="copyright">Copyright © 2019 The Apache Software Foundation</section></footer></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: '0fedc89dddf2810657708b178e56ef02',
                indexName: 'streampipes',
                inputSelector: '#search_input_react',
                algoliaOptions: {}
              });
            </script></body></html>