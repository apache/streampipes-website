"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[97637],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>m});var r=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=r.createContext({}),c=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=c(e.components);return r.createElement(l.Provider,{value:t},e.children)},h="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},u=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),h=c(n),u=o,m=h["".concat(l,".").concat(u)]||h[u]||d[u]||a;return n?r.createElement(m,i(i({ref:t},p),{},{components:n})):r.createElement(m,i({ref:t},p))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,i=new Array(a);i[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[h]="string"==typeof e?e:o,i[1]=s;for(var c=2;c<a;c++)i[c]=n[c];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}u.displayName="MDXCreateElement"},63179:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>l,default:()=>m,frontMatter:()=>s,metadata:()=>c,toc:()=>h});var r=n(87462),o=n(63366),a=(n(67294),n(3905)),i=["components"],s={title:"ContainerCLI: A CLI tool for your Docker Application",author:"Philipp Zehnder",authorURL:"http://twitter.com/philipp10der",authorImageURL:"/img/zehnder.png"},l=void 0,c={permalink:"/blog/2018/11/24/container-cli",source:"@site/blog/2018-11-24-container-cli.md",title:"ContainerCLI: A CLI tool for your Docker Application",description:"6 minutes to read",date:"2018-11-24T00:00:00.000Z",formattedDate:"November 24, 2018",tags:[],readingTime:3.91,hasTruncateMarker:!0,authors:[{name:"Philipp Zehnder",url:"http://twitter.com/philipp10der",imageURL:"/img/zehnder.png"}],frontMatter:{title:"ContainerCLI: A CLI tool for your Docker Application",author:"Philipp Zehnder",authorURL:"http://twitter.com/philipp10der",authorImageURL:"/img/zehnder.png"},prevItem:{title:"StreamPipes release 0.61.0",permalink:"/blog/2019/04/04/release-0610"},nextItem:{title:"Preview: StreamPipes release 0.60.0",permalink:"/blog/2018/09/17/preview-060"}},p={authorsImageUrls:[void 0]},h=[],d={toc:h},u="wrapper";function m(e){var t=e.components,n=(0,o.Z)(e,i);return(0,a.kt)(u,(0,r.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("div",{style:{float:"left",paddingRight:"40px"}},"6 minutes to read"))),(0,a.kt)("br",null),(0,a.kt)("p",null,"In this blog post, we show how we developed a CLI tool to install and manage StreamPipes.\nIn addition, we present a template project that enables you to easily create a CLI tool for your own docker application.\nAll you need is a working docker-compose.yml file."),(0,a.kt)("p",null,"StreamPipes has a Microservice architecture and we use Docker and Docker Compose for all of our development, testing, and deployment processes.\nIn the beginning, we developed the CLI only to ease the installation process (e.g. managing multiple versions), but over time we realized that the tool is much more powerful.\nFor example, StreamPipes has multiple developer roles: Some developers are working on the frontend, others on the backend, and some are developing new algorithms and data sinks for StreamPipes.\nIn the figure below, you can see different configurations that are used by different developers.\nAll services are running in docker, except for the ones the developer is currently working on.\nAs a result, we had many different docker-compose.yml files and when we made changes, we had to synchronize them all."),(0,a.kt)("img",{class:"blog-image",style:{maxWidth:"60%"},src:"/img/blog/2018-11-24/roles.png",alt:"Three different developer roles"}),(0,a.kt)("p",null,"Therefore, our goal was to speed up the setup of a development environment, so that developers can focus on their specific programming task.\nThat\u2019s why we developed a command line tool that automates the setup of different environments.\nAll what is needed is a docker-compose.yml file that describes all services of the application and the template CLI project from ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/streampipes/container-cli"},"GitHub"),".\nAfterwards, you need to split up your compose file and create an individual file for each service. Put those files in individual folders in the services folder.\nEach folder should have the same name as the service name in the docker-compose file. That\u2019s it!\nNow you can use the CLI.\nWith the default commands you are able to start, stop, and configure the application. But how is this better than just using docker itself?\nThe advantage is the flexibility and extensibility of the tool.\nYou can extend the script with tasks you have to perform regularly, like cleaning up volumes, or setting up testing environments."),(0,a.kt)("p",null,"In the following we will describe the tool in more detail.\nYou can see all files and folders of the CLI Tool in the next listing.\nThe first file \u201ccontainer-cli.m4\u201d contains the script.\nWe use ",(0,a.kt)("a",{parentName:"p",href:"https://argbash.io/"},"Argbash"),", which eases the use of bash script parameters and flags.\nIn this file you can easily add new custom commands, flags or other functionalities.\nThe next file is the actual bash script. It is generated by argbash.\nSince this file is generated automatically, you should not change anything.\nThe docker-compose.yml file is the main file.\nThis should contain all services, networks, or volume information that is relevant for all the other services of your application.\nAll your other services are located in the services folder.\nFor each service, create a folder with the name of the service and place a docker-compose.yml in the folder configuring the service.\nTherefore, you can copy and paste the configuration from your current docker-compose.yml.\nThe script checks the services folder dynamically, this means you can add services at a later point in time without changing anything else.\nIn our example, we have four services: Backend, UI, database, and a test database containing data for the end2end tests.\nWhich services should be started when running the command ",(0,a.kt)("strong",{parentName:"p"},'"container-cli start"')," is defined in the active-service file.\nThis file contains the names of all services, each in one line, that should be started.\nOften it is required to have multiple configurations of your app. You can save them in the templates folder.\nBy running ",(0,a.kt)("strong",{parentName:"p"},"\u201ccontainer-cli set-template ui_developer\u201d"),", you can select the template ui_developer.\nWith this command, all services defined in the template are written to the active-services file. (e.g. the ui_developer template contains just the database and backend and the e2e-test template contains the backend, ui, and test-database)."),(0,a.kt)("img",{class:"blog-image",style:{maxWidth:"30%"},src:"/img/blog/2018-11-24/files.png",alt:"Structure of the containter cli project"}),(0,a.kt)("p",null,"The last file is the tmpl_env file.\nIt contains configuration variables for the individual services.\nThose variables can also be changed by the bash script dynamically, because the tmpl_env file is moved to the .env file in the same folder.\nWe use the configuration for example to dynamically set the IP Address of the host system or set the application version.\nTo use a variable in a docker-compose file just write it in braces, as shown below."),(0,a.kt)("img",{className:"blog-image",style:{maxWidth:"90%"},src:"/img/blog/2018-11-24/variables.png",alt:"How to use Environment Variables"}),(0,a.kt)("p",null,"We hope this tool is helpful for your use case.\nWhen you have any problems, feedback, or ideas for improvements, contact us or open an issue on ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/streampipes/container-cli"},"GitHub"),"."))}m.isMDXComponent=!0}}]);