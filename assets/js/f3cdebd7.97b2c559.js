"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[62075],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>h});var i=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},r=Object.keys(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=i.createContext({}),p=function(e){var t=i.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=p(e.components);return i.createElement(l.Provider,{value:t},e.children)},c="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},g=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),c=p(n),g=a,h=c["".concat(l,".").concat(g)]||c[g]||m[g]||r;return n?i.createElement(h,o(o({ref:t},d),{},{components:n})):i.createElement(h,o({ref:t},d))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,o=new Array(r);o[0]=g;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[c]="string"==typeof e?e:a,o[1]=s;for(var p=2;p<r;p++)o[p]=n[p];return i.createElement.apply(null,o)}return i.createElement.apply(null,n)}g.displayName="MDXCreateElement"},19443:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>l,default:()=>h,frontMatter:()=>s,metadata:()=>p,toc:()=>c});var i=n(87462),a=n(63366),r=(n(67294),n(3905)),o=["components"],s={id:"extend-sdk-migration",title:"SDK Guide: Pipeline Element Migration",sidebar_label:"SDK: PE Migration"},l=void 0,p={unversionedId:"extend-sdk-migration",id:"version-0.97.0/extend-sdk-migration",title:"SDK Guide: Pipeline Element Migration",description:"Pipeline element migrations allow you to automatically update and migrate both existing and pipeline elements when a new",source:"@site/versioned_docs/version-0.97.0/06_extend-sdk-migrations.md",sourceDirName:".",slug:"/extend-sdk-migration",permalink:"/docs/extend-sdk-migration",draft:!1,tags:[],version:"0.97.0",lastUpdatedBy:"Philipp Zehnder",lastUpdatedAt:1739799205,formattedLastUpdatedAt:"Feb 17, 2025",sidebarPosition:6,frontMatter:{id:"extend-sdk-migration",title:"SDK Guide: Pipeline Element Migration",sidebar_label:"SDK: PE Migration"},sidebar:"documentation",previous:{title:"SDK: Event Model",permalink:"/docs/extend-sdk-event-model"},next:{title:"SDK: Stream Requirements",permalink:"/docs/extend-sdk-stream-requirements"}},d={},c=[{value:"Define Migrations",id:"define-migrations",level:2},{value:"Implementing a Concrete Migration",id:"implementing-a-concrete-migration",level:3},{value:"Registering the Migration",id:"registering-the-migration",level:3},{value:"How Migrations are Handled Internally",id:"how-migrations-are-handled-internally",level:2},{value:"Update Descriptions for New Elements",id:"update-descriptions-for-new-elements",level:3},{value:"Update Descriptions for Existing Elements",id:"update-descriptions-for-existing-elements",level:3}],m={toc:c},g="wrapper";function h(e){var t=e.components,n=(0,a.Z)(e,o);return(0,r.kt)(g,(0,i.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Pipeline element migrations allow you to automatically update and migrate both existing and pipeline elements when a new\nversion of StreamPipes is installed. This means that whenever you upgrade StreamPipes, all existing and future\npipeline elements will be directly compatible with the new version without any manual interaction. Pipeline elements\ninclude adapters, data processors, and data sinks."),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"Migrations will make their debut in StreamPipes version ",(0,r.kt)("inlineCode",{parentName:"p"},"0.93.0")," and will be an integral part of the system going\nforward.\nHowever, it's important to note that this feature is not available in any of the previous versions of StreamPipes. To\ntake full advantage of migrations and their benefits, it is recommended to upgrade to version ",(0,r.kt)("inlineCode",{parentName:"p"},"0.93.0")," or later. This\nwill\nensure that you have access to the latest enhancements and maintain compatibility with the evolving StreamPipes\nplatform.")),(0,r.kt)("h2",{id:"define-migrations"},"Define Migrations"),(0,r.kt)("p",null,"Whenever a pipeline element, be it an adapter, data processor, or data sink, undergoes changes that result in\nmodifications to its configuration options, developers must additionally create a migration procedure. This migration\nprocess should be capable of smoothly transitioning all affected instances from the previous version to the new one.\nThe migration itself is automatically managed and executed by StreamPipes. Developers are only responsible for two key\naspects:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Implementing the concrete migration"),": Developers need to craft the specific migration logic that facilitates the\nseamless transition of configuration options."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Registering the migration"),": Developers should register their migration procedures at the extensions service,\nallowing StreamPipes to identify and apply the necessary updates to affected instances.")),(0,r.kt)("p",null,"By adhering to these two essential tasks, developers can ensure a hassle-free evolution of pipeline elements while\nStreamPipes handles the orchestration of the migration process."),(0,r.kt)("p",null,"The following gives a concrete example of creating a migration for\nthe ",(0,r.kt)("a",{parentName:"p",href:"/docs/pe/org.apache.streampipes.connect.iiot.adapters.plc4x.s7"},"S7 adapter"),".\nThereby, we assume this adapter has received a new input element which determines whether the connection should be made\nauthenticated or not.\nThis is represented by a simple boolean that is visualized as a toggle button in the UI."),(0,r.kt)("h3",{id:"implementing-a-concrete-migration"},"Implementing a Concrete Migration"),(0,r.kt)("p",null,"StreamPipes offers three distinct migration mechanisms tailored to specific types of pipeline\nelements: ",(0,r.kt)("inlineCode",{parentName:"p"},"IAdapterMigrator"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"IDataProcessorMigrator"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"IDataSinkMigrator"),".\nThese migration mechanisms are presented as interfaces and require the implementation of two fundamental methods:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"config()"),": This method defines the configuration for the migration, encompassing all essential metadata related to\nthe migration process."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"migrate()"),": Within this method, the actual migration logic is to be implemented. It serves as the operational core\nfor facilitating the migration for the respective pipeline element.")),(0,r.kt)("p",null,"In accordance with the example described above, we will implement the ",(0,r.kt)("inlineCode",{parentName:"p"},"Plc4xS7AdapterMigrationV1")," in the following."),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"Before we begin, it's important to familiarize ourselves with two key conventions that guide our approach to migrations:"),(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},"To maintain clarity and organization, all migration classes associated with a specific pipeline element are located\nwithin a dedicated sub-package named ",(0,r.kt)("inlineCode",{parentName:"li"},"migration"),". This sub-package is nested within the package of the respective\npipeline element."),(0,r.kt)("li",{parentName:"ul"},"Migration classes are named according to a specific schema: ",(0,r.kt)("inlineCode",{parentName:"li"},"<elementClassName>MigrationV<targetVersion>"),". For\nexample, if you are working on a migration for the PLC4x S7 adapter targeting version 1, the migration class would be\nnamed ",(0,r.kt)("inlineCode",{parentName:"li"},"Plc4xS7AdapterMigrationV1"),"."))),(0,r.kt)("p",null,"Let's begin with providing the migration's configuration:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'@Override\npublic ModelMigratorConfig config() {\n  return new ModelMigratorConfig(\n          "org.apache.streampipes.connect.iiot.adapters.plc4x.s7",\n          SpServiceTagPrefix.ADAPTER,\n          0,\n          1\n  );\n}\n')),(0,r.kt)("p",null,"The migration config consists of the following four parts:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"targetAppId"),": this needs to equal the app id of the targeted element"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"modelType"),": the type of the element to be migrated, this can be one\nof: ",(0,r.kt)("inlineCode",{parentName:"li"},"SpServiceTagPrefix.ADAPTER"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"SpServiceTagPrefix.DATA_PROCESSOR"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"SpServiceTagPrefix.DATA_SINK"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"fromVersion"),": the version of the element that the migration expects as input"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"toVersion"),": the version the element has after the migration (needs to be at least ",(0,r.kt)("inlineCode",{parentName:"li"},"fromVersion + 1"),")")),(0,r.kt)("p",null,"The second step is to implement the actual migration logic.\nIn our example, we need to extend the existing static properties by an additional boolean property."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'@Override\npublic MigrationResult<AdapterDescription> migrate(AdapterDescription element, IStaticPropertyExtractor extractor) throws RuntimeException {\n\n  var config = element.getConfig();\n\n  var slideToggle = new SlideToggleStaticProperty();\n  slideToggle.setDefaultValue(false);\n  slideToggle.setLabel("Authentication required?");\n  config.add(slideToggle);\n\n  element.setConfig(config);\n  return MigrationResult.success(element);\n}\n')),(0,r.kt)("p",null,"We've completed all the necessary steps for our migration. The final task remaining is to register the migration within\nthe service definition."),(0,r.kt)("h3",{id:"registering-the-migration"},"Registering the Migration"),(0,r.kt)("p",null,"Only when the migration is registered at the service definition, the migration is sent to the StreamPipes core service.\nTherefore, we need to add the migration to the same service definition as the element to migrate.\nIn our example this is defined in ",(0,r.kt)("inlineCode",{parentName:"p"},"ConnectAdapterIiotInit"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java",metastring:"jsx {22-24} showLineNumbers",jsx:!0,"{22-24}":!0,showLineNumbers:!0},'@Override\npublic SpServiceDefinition provideServiceDefinition() {\n  return SpServiceDefinitionBuilder.create("connect-adapter-iiot",\n          "StreamPipes connect worker containing adapters relevant for the IIoT",\n          "",\n          8001)\n      .registerAdapter(new MachineDataSimulatorAdapter())\n      .registerAdapter(new FileReplayAdapter())\n      .registerAdapter(new IfmAlMqttAdapter())\n      .registerAdapter(new RosBridgeAdapter())\n      .registerAdapter(new OpcUaAdapter())\n      .registerAdapter(new Plc4xS7Adapter())\n      .registerAdapter(new Plc4xModbusAdapter())\n      .registerAdapter(new KafkaProtocol())\n      .registerAdapter(new MqttProtocol())\n      .registerAdapter(new NatsProtocol())\n      .registerAdapter(new HttpStreamProtocol())\n      .registerAdapter(new PulsarProtocol())\n      .registerAdapter(new RocketMQProtocol())\n      .registerAdapter(new HttpServerProtocol())\n      .registerAdapter(new TubeMQProtocol())\n      .registerMigrators(\n          new Plc4xS7AdapterMigrationV1()\n      )\n      .build();\n')),(0,r.kt)("br",null),(0,r.kt)("h2",{id:"how-migrations-are-handled-internally"},"How Migrations are Handled Internally"),(0,r.kt)("p",null,"Migrations are handled by an interplay between the Extension Service, which provides the migrations,\nand the StreamPipes Core Service, which manages the migrations, as shown in the figure below:"),(0,r.kt)("img",{src:"/img/06_sdk_migrations/migration-flow.png",alt:"Interplay of extensions service and core to handle migrations"}),(0,r.kt)("p",null,"When an extensions service is initiated and has successfully registered itself with the core, it proceeds to send a\nrequest to the core. This request includes a comprehensive list of all available migrations that have been registered\nfor it. Since this collection of migrations may encompass multiple migrations that affect the same pipeline element,\nthe migrations are first de-duplicated and then sorted based on their version range before being transmitted."),(0,r.kt)("p",null,"Upon receiving these migrations, the core's actions can be categorized into two distinct parts:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Update descriptions for new elements"),(0,r.kt)("li",{parentName:"ul"},"Update descriptions for existing elements")),(0,r.kt)("h3",{id:"update-descriptions-for-new-elements"},"Update Descriptions for New Elements"),(0,r.kt)("p",null,"Each migration transmitted from the extensions service to the core triggers the core to update the description of the\ncorresponding element stored in CouchDB. This is achieved by requesting the current configuration from the extensions\nservice and subsequently overwriting the existing configuration in the storage."),(0,r.kt)("h3",{id:"update-descriptions-for-existing-elements"},"Update Descriptions for Existing Elements"),(0,r.kt)("p",null,"For each migration sent from the extensions service to the core, the core conducts a thorough check to determine if any\nexisting elements are affected by this migration. If such elements are identified, the extensions service is tasked with\nrequesting and subsequently executing the migration on behalf of the core."),(0,r.kt)("p",null,"In scenarios where multiple applicable migrations exist for a single pipeline element, they are sequentially applied.\nSuccess in this process allows the core to seamlessly update the configuration. However, if any issues arise, the\ncorresponding pipeline element is halted. In the case of processors and sinks, the associated pipeline is even marked\nwith a ",(0,r.kt)("inlineCode",{parentName:"p"},"needs attention")," label, which comes apparent in the UI."))}h.isMDXComponent=!0}}]);