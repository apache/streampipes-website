"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[98586],{3905:(e,t,r)=>{r.d(t,{Zo:()=>m,kt:()=>h});var a=r(67294);function i(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function n(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,a)}return r}function o(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?n(Object(r),!0).forEach((function(t){i(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):n(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,a,i=function(e,t){if(null==e)return{};var r,a,i={},n=Object.keys(e);for(a=0;a<n.length;a++)r=n[a],t.indexOf(r)>=0||(i[r]=e[r]);return i}(e,t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);for(a=0;a<n.length;a++)r=n[a],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(i[r]=e[r])}return i}var l=a.createContext({}),p=function(e){var t=a.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):o(o({},t),e)),r},m=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},c="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var r=e.components,i=e.mdxType,n=e.originalType,l=e.parentName,m=s(e,["components","mdxType","originalType","parentName"]),c=p(r),d=i,h=c["".concat(l,".").concat(d)]||c[d]||u[d]||n;return r?a.createElement(h,o(o({ref:t},m),{},{components:r})):a.createElement(h,o({ref:t},m))}));function h(e,t){var r=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var n=r.length,o=new Array(n);o[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[c]="string"==typeof e?e:i,o[1]=s;for(var p=2;p<n;p++)o[p]=r[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,r)}d.displayName="MDXCreateElement"},43511:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>m,contentTitle:()=>l,default:()=>h,frontMatter:()=>s,metadata:()=>p,toc:()=>c});var a=r(87462),i=r(63366),n=(r(67294),r(3905)),o=["components"],s={title:"StreamPi(pes) - Running StreamPipes on Raspberry Pi",author:"Patrick Wiener",authorURL:"https://twitter.com/patrickwiener",authorImageURL:"/img/wiener.png"},l=void 0,p={permalink:"/blog/2020/01/23/streampipes_on_rpi",source:"@site/blog/2020-01-23-streampipes_on_rpi.md",title:"StreamPi(pes) - Running StreamPipes on Raspberry Pi",description:"5 minutes to read",date:"2020-01-23T00:00:00.000Z",formattedDate:"January 23, 2020",tags:[],readingTime:5.315,hasTruncateMarker:!0,authors:[{name:"Patrick Wiener",url:"https://twitter.com/patrickwiener",imageURL:"/img/wiener.png"}],frontMatter:{title:"StreamPi(pes) - Running StreamPipes on Raspberry Pi",author:"Patrick Wiener",authorURL:"https://twitter.com/patrickwiener",authorImageURL:"/img/wiener.png"},prevItem:{title:"Apache StreamPipes release 0.66.0",permalink:"/blog/2020/05/19/release-0660"},nextItem:{title:"Moving to the Apache Incubator",permalink:"/blog/2019/11/25/moving-to-the-apache-incubator"}},m={authorsImageUrls:[void 0]},c=[{value:"Demo: Temperature Monitoring Pipeline",id:"demo-temperature-monitoring-pipeline",level:3},{value:"So, what&#39;s next?",id:"so-whats-next",level:3},{value:"Useful links",id:"useful-links",level:3}],u={toc:c},d="wrapper";function h(e){var t=e.components,r=(0,i.Z)(e,o);return(0,n.kt)(d,(0,a.Z)({},u,r,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("img",{class:"blog-image",style:{maxWidth:"100%"},src:"/img/blog/2020-01-23/streampipes_raspberrypi.png",alt:"StreamPipes on Raspberry Pi"}),"**",(0,n.kt)("div",{style:{float:"left",paddingRight:"40px"}},"5 minutes to read"),"**",(0,n.kt)("br",null),(0,n.kt)("p",null,"This is the start of a two part series on how we want to bring StreamPipes closer to the edge. The ",(0,n.kt)("a",{parentName:"p",href:"/docs/blog/2020/01/23/streampipes_on_rpi"},"first part")," describes how we managed to build and deploy StreamPipes on one Raspberry Pi (Model 4), while the ",(0,n.kt)("a",{parentName:"p",href:"/docs/blog/2020/05/27/streampipes_on_k3s"},"second part")," further covers how to deploy StreamPipes over a Kubernetes cluster of two Raspberry Pi's via K3s using our StreamPipes helm chart."),(0,n.kt)("p",null,"<TL;DR>"),(0,n.kt)("p",null,(0,n.kt)("em",{parentName:"p"},"With new advancements that came in the last StreamPipes release, we managed to reduce the required resources (mainly memory) drastically. To this extent, we cross-compiled StreamPipes Docker images for ARM support and deployed our lite version on a Raspberry Pi (Model 4). We showcase, that it is feasible to run analytical pipelines with ease and operate StreamPipes at moderate load.")),(0,n.kt)("p",null,"Apache StreamPipes (incubating) is a self-service (Industrial) IoT toolbox to enable non-technical users to easily connect, analyze and explore IoT data streams. Users can leverage algorithms from an extensible toolbox to model their analytical pipelines. By building on a microservice architecture, StreamPipes components can be distributed in a cluster (e.g. Kubernetes)  as well as run on a single node for prototypical and development purposes using Docker. With the latest release of StreamPipes (0.65.0), we managed to reduce the memory consumption drastically to use less than 2Gig\u2018s of RAM for the lite version. Since we had a Raspberry Pi Model 4 laying around, we thought: hey why not just deploy StreamPipes on a Pi - and that\u2019s what we did. Along the way, we learned quite some interesting things, that we want to share in this blog post."),(0,n.kt)("p",null,"When users model their analytical pipelines using the graphical pipeline editor, the corresponding pipeline element containers, hosting these algorithms, are invoked by a rest call from the backend to start a new thread with the corresponding algorithm. In typical edge use cases such as in the industrial internet of things (IIoT), it is oftentimes neither feasible nor necessary to simply send all raw data to the cloud to perform analytics. On the contrary, requirements often induce the challenges to either derive decisions in a time-sensitive manner (near realtime), preprocess  data to reduce and harmonize it, or anonymize it by pixeling personal information such as faces in video footages. In these scenarios, StreamPipes can aid by running dedicated pipeline element containers directly on the edge using edge nodes such as Raspberry Pi\u2018s close to where data origins to address the aforementioned challenges."),(0,n.kt)("img",{class:"blog-image",align:"center",style:{maxWidth:"80%"},src:"/img/blog/2020-01-23/00_idea.png",alt:"StreamPipes lite on Raspberry Pi"}),(0,n.kt)("p",null,"StreamPipes Docker images were only built for x86 based architectures. However, oftentimes edge devices such as Raspberry Pi's or Nvidia Jetson Nano's run ARM based 32 or 64bit architectures. Thus, we could not simply use our existing Docker images to deploy StreamPipes as is. Luckily, Docker offers solutions to cross-compile images. Together with Docker\u2018s experimental manifest feature, the deployment works like a charms [",(0,n.kt)("a",{parentName:"p",href:"https://docs.docker.com/engine/reference/commandline/manifest/"},"1"),"]. There are awesome blog posts online [",(0,n.kt)("a",{parentName:"p",href:"https://ownyourbits.com/2018/06/27/running-and-building-arm-docker-containers-in-x86/"},"2"),"] that guide you through the process of cross-compilation, so we are not going to cover it in this blog post. With that, we were able to build StreamPipes images for AMD, ARM32v7 and ARM64v8 by just adding a few lines to our Dockerfiles and CI/CD pipelines. After having built and pushed our newly created Docker images, we were able to use our existing installation workflow, e.g. StreamPipes CLI, to start StreamPipes on the Raspberry Pi."),(0,n.kt)("img",{class:"blog-image",style:{maxWidth:"100%"},src:"/img/blog/2020-01-23/01_start.png",alt:"StreamPipes CLI starting StreamPipes lite version on Raspberry Pi 4"}),(0,n.kt)("p",null,"The figure shows StreamPipes CLI starting our internal ",(0,n.kt)("inlineCode",{parentName:"p"},"0.65.1-SNAPSHOT")," version, where we tested the multiarch build of our images. As depicted, all StreamPipes lite services are started. Due to the fact, that we created a manifest for all our Docker images, we did not have to change a single image description specified in the various ",(0,n.kt)("inlineCode",{parentName:"p"},"docker-compose.yml")," files in the service repository. This is pretty cool! The Docker daemon automatically pulls the correct image for the corresponding architecture - in our case ARM32v7. Taking a quick look at ",(0,n.kt)("inlineCode",{parentName:"p"},"htop")," indicates that we operate on a constant level of consumed memory at around ~1.7GB."),(0,n.kt)("img",{class:"blog-image",style:{maxWidth:"100%"},src:"/img/blog/2020-01-23/02_htop.png",alt:"htop showing around 1.7GB memory consumption"}),(0,n.kt)("h3",{id:"demo-temperature-monitoring-pipeline"},"Demo: Temperature Monitoring Pipeline"),(0,n.kt)("p",null,"To test our setup, we deployed a simple temperature monitoring pipeline, that throws a notification whenever the temperature value exceeds a certain threshold (in this case: 65\xb0C) and visualizes the results in a basic dashboard (see figure). Therefore, we use existing pipeline elements of the algorithm toolbox provided within the lite version. Thereby, StreamPipes lite already hooks you up with sample data sources - in this case a flow rate sensor - producing temperature, as well as mass flow measurements. So our temperature monitoring pipeline consists of the following pipeline elements:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Data source:")," Flow rate sensor (mock data generating ",(0,n.kt)("inlineCode",{parentName:"li"},"<timestamp;sensorid;massflow;temperature>")," each second)"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Data processor:")," Numerical filter (specified temperature threshold: > 65\xb0C)"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"Data sinks:")," Dashboard visualization, Notification (internal)")),(0,n.kt)("img",{class:"blog-image",style:{maxWidth:"100%"},src:"/img/blog/2020-01-23/03_pipeline.png",alt:"Simple pipeline visualizing and notifying about temperature values above threshold (here 65\xb0C)"}),(0,n.kt)("p",null,"After saving and starting the pipeline, we built our dashboard based on the results of the pipeline, only showing values above 65\xb0C. Additionally, we receive a notification for every event, that exceeds this temperature threshold."),(0,n.kt)("img",{class:"blog-image",style:{maxWidth:"100%"},src:"/img/blog/2020-01-23/04_dashboard.png",alt:"Dashboard"}),(0,n.kt)("h3",{id:"so-whats-next"},"So, what's next?"),(0,n.kt)("p",null,"Starting out as a simple hack session on a late afternoon, trying to test where we could potentially run StreamPipes on and push it to it's limits, we gained valueable insights on how to build and run it on various architectures. Even though we do not recommend deploying StreamPipes in it's full glory on single low-resourced devices such as Raspberry Pi's, we aim to bring certain algorithms closer to where data is generated - on the edge. Consequently - apart from x86 images - we plan on providing our StreamPipes Docker images for ARM based architectures in the future. As a sneak peak - we also plan on deploying StreamPipes over a K3s [",(0,n.kt)("a",{parentName:"p",href:"https://k3s.io/"},"3"),"] cluster, a lightweight Kubernetes distro especially suited for IoT and edge scenarios."),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},(0,n.kt)("a",{parentName:"strong",href:"/blog/2020/01/23/streampipes_on_rpi"},"Part 1: StreamPi(pes) - Running StreamPipes on Raspberry Pi"))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"/blog/2020/05/27/streampipes_on_k3s"},"Part 2: Running StreamPipes the Kubernetes-Way using K3s"))),(0,n.kt)("h3",{id:"useful-links"},"Useful links"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"[1][Docker manifest docs]","(",(0,n.kt)("a",{parentName:"li",href:"https://docs.docker.com/engine/reference/commandline/manifest/"},"https://docs.docker.com/engine/reference/commandline/manifest/"),")"),(0,n.kt)("li",{parentName:"ul"},"[2][Running and Building ARM Docker containers in x86]","(",(0,n.kt)("a",{parentName:"li",href:"https://ownyourbits.com/2018/06/27/running-and-building-arm-docker-containers-in-x86/"},"https://ownyourbits.com/2018/06/27/running-and-building-arm-docker-containers-in-x86/"),")"),(0,n.kt)("li",{parentName:"ul"},"[3][K3s - lightweight Kubernetes distro]","(",(0,n.kt)("a",{parentName:"li",href:"https://k3s.io/"},"https://k3s.io/"),")")))}h.isMDXComponent=!0}}]);