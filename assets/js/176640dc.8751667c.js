"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[63402],{3905:(e,t,r)=>{r.d(t,{Zo:()=>u,kt:()=>f});var n=r(67294);function i(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function a(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function o(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?a(Object(r),!0).forEach((function(t){i(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,n,i=function(e,t){if(null==e)return{};var r,n,i={},a=Object.keys(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||(i[r]=e[r]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(i[r]=e[r])}return i}var p=n.createContext({}),l=function(e){var t=n.useContext(p),r=t;return e&&(r="function"==typeof e?e(t):o(o({},t),e)),r},u=function(e){var t=l(e.components);return n.createElement(p.Provider,{value:t},e.children)},m="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},c=n.forwardRef((function(e,t){var r=e.components,i=e.mdxType,a=e.originalType,p=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),m=l(r),c=i,f=m["".concat(p,".").concat(c)]||m[c]||d[c]||a;return r?n.createElement(f,o(o({ref:t},u),{},{components:r})):n.createElement(f,o({ref:t},u))}));function f(e,t){var r=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=r.length,o=new Array(a);o[0]=c;var s={};for(var p in t)hasOwnProperty.call(t,p)&&(s[p]=t[p]);s.originalType=e,s[m]="string"==typeof e?e:i,o[1]=s;for(var l=2;l<a;l++)o[l]=r[l];return n.createElement.apply(null,o)}return n.createElement.apply(null,r)}c.displayName="MDXCreateElement"},17606:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>u,contentTitle:()=>p,default:()=>f,frontMatter:()=>s,metadata:()=>l,toc:()=>m});var n=r(87462),i=r(63366),a=(r(67294),r(3905)),o=["components"],s={id:"extend-sdk-stream-requirements",title:"SDK Guide: Stream Requirements",sidebar_label:"SDK: Stream Requirements"},p=void 0,l={unversionedId:"extend-sdk-stream-requirements",id:"extend-sdk-stream-requirements",title:"SDK Guide: Stream Requirements",description:"Introduction",source:"@site/../docs/06_extend-sdk-stream-requirements.md",sourceDirName:".",slug:"/extend-sdk-stream-requirements",permalink:"/docs/next/extend-sdk-stream-requirements",draft:!1,tags:[],version:"current",lastUpdatedBy:"Dominik Riemer",lastUpdatedAt:1689178337,formattedLastUpdatedAt:"Jul 12, 2023",sidebarPosition:6,frontMatter:{id:"extend-sdk-stream-requirements",title:"SDK Guide: Stream Requirements",sidebar_label:"SDK: Stream Requirements"},sidebar:"documentation",previous:{title:"SDK: Event Model",permalink:"/docs/next/extend-sdk-event-model"},next:{title:"SDK: Static Properties",permalink:"/docs/next/extend-sdk-static-properties"}},u={},m=[{value:"Introduction",id:"introduction",level:2},{value:"The StreamRequirementsBuilder",id:"the-streamrequirementsbuilder",level:2},{value:"Requirements on primitive fields",id:"requirements-on-primitive-fields",level:2},{value:"Specifying semantics",id:"specifying-semantics",level:3},{value:"Requirements on lists",id:"requirements-on-lists",level:2},{value:"Requirements on nested properties",id:"requirements-on-nested-properties",level:2}],d={toc:m},c="wrapper";function f(e){var t=e.components,r=(0,i.Z)(e,o);return(0,a.kt)(c,(0,n.Z)({},d,r,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h2",{id:"introduction"},"Introduction"),(0,a.kt)("p",null,"Data processors and data sinks can define ",(0,a.kt)("inlineCode",{parentName:"p"},"StreamRequirements"),". Stream requirements allow pipeline elements to express requirements on an incoming event stream that are needed for the element to work properly.\nOnce users create pipelines in the StreamPipes Pipeline Editor, these requirements are verified against the connected event stream.\nBy using this feature, StreamPipes ensures that only pipeline elements can be connected that are syntactically and semantically valid."),(0,a.kt)("p",null,"This guide covers the creation of stream requirements. Before reading this section, we recommend that you make yourself familiar with the SDK guide on ",(0,a.kt)("a",{parentName:"p",href:"extend-first-processor"},"data processors"),"."),(0,a.kt)("admonition",{title:"Code on Github",type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"For all examples, the code can be found on ",(0,a.kt)("a",{parentName:"p",href:"https://www.github.com/apache/streampipes-examples/tree/dev/streampipes-pipeline-elements-examples-processors-jvm/src/main/java/org/apache/streampipes/pe/examples/jvm/requirements/"},"Github"),".")),(0,a.kt)("h2",{id:"the-streamrequirementsbuilder"},"The StreamRequirementsBuilder"),(0,a.kt)("p",null,"Stream requirements can be defined in the ",(0,a.kt)("inlineCode",{parentName:"p"},"declareModel")," method of the pipeline element class. Start with a method body like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},"\n@Override\n  public DataProcessorDescription declareModel() {\n    return ProcessingElementBuilder.create(ID, PIPELINE_ELEMENT_NAME, DESCRIPTION)\n            .requiredStream(StreamRequirementsBuilder.\n                    create()\n\n                    .build())\n\n            .supportedProtocols(SupportedProtocols.kafka())\n            .supportedFormats(SupportedFormats.jsonFormat())\n            .outputStrategy(OutputStrategies.keep())\n\n            .build();\n  }\n")),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"StreamRequirementsBuilder")," class provides methods to add stream requirements to a pipeline element."),(0,a.kt)("h2",{id:"requirements-on-primitive-fields"},"Requirements on primitive fields"),(0,a.kt)("p",null,"As a very first example, let's assume we would like to create a data processor that filters numerical values that are above a given threshold.\nConsequently, any data stream that is connected to the filter processor needs to provide a numerical value."),(0,a.kt)("p",null,"The stream requirement would be assigned as follows:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},"@Override\n  public DataProcessorDescription declareModel() {\n    return ProcessingElementBuilder.create(ID, PIPELINE_ELEMENT_NAME, DESCRIPTION)\n            .requiredStream(StreamRequirementsBuilder\n                    .create()\n                    .requiredProperty(EpRequirements.numberReq())\n                    .build())\n\n            .supportedProtocols(SupportedProtocols.kafka())\n            .supportedFormats(SupportedFormats.jsonFormat())\n            .outputStrategy(OutputStrategies.keep())\n\n            .build();\n  }\n")),(0,a.kt)("p",null,"Note the line starting with ",(0,a.kt)("inlineCode",{parentName:"p"},"requiredProperty"),", which requires any stream to provide a datatype of type ",(0,a.kt)("inlineCode",{parentName:"p"},"number"),"."),(0,a.kt)("p",null,"In many cases, you'll want to let the user select a specific field from a data stream from all available fields that match the specified requirement. For that, you simply use the method ",(0,a.kt)("inlineCode",{parentName:"p"},"requiredPropertyWithUnaryMapping")," as follows:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},'@Override\n  public DataProcessorDescription declareModel() {\n    return ProcessingElementBuilder.create(ID, PIPELINE_ELEMENT_NAME, DESCRIPTION)\n            .requiredStream(StreamRequirementsBuilder\n                    .create()\n                    .requiredPropertyWithUnaryMapping(EpRequirements.numberReq(),\n                    Labels.from("number-mapping", "The value that should be filtered", ""), PropertyScope.NONE)\n                    .build())\n\n            .supportedProtocols(SupportedProtocols.kafka())\n            .supportedFormats(SupportedFormats.jsonFormat())\n            .outputStrategy(OutputStrategies.keep())\n\n            .build();\n  }\n')),(0,a.kt)("p",null,"See also the developer guide on ",(0,a.kt)("a",{parentName:"p",href:"extend-sdk-static-properties"},"static properties")," to better understand the usage of ",(0,a.kt)("inlineCode",{parentName:"p"},"MappingProperties"),"."),(0,a.kt)("p",null,"Requirements on primitive fields can be specified for all common datatypes:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},' @Override\n  public DataProcessorDescription declareModel() {\n    return ProcessingElementBuilder.create("org.streampipes.examples.requirements" +\n            ".simple", "Simple requirements specification examples", "")\n            .requiredStream(StreamRequirementsBuilder.\n                    create()\n                    .requiredProperty(EpRequirements.numberReq()) // any number\n                    .requiredProperty(EpRequirements.doubleReq()) // any field of type double\n                    .requiredProperty(EpRequirements.booleanReq()) // any field of type boolean\n                    .requiredProperty(EpRequirements.integerReq()) // any field of type integer\n                    .requiredProperty(EpRequirements.stringReq()) // any field of type string\n\n                    .requiredProperty(EpRequirements.anyProperty()) // any field allowed (no restriction)\n                    .requiredProperty(EpRequirements.timestampReq())  // any timestamp field\n                    .build())\n\n\n            .supportedProtocols(SupportedProtocols.kafka())\n            .supportedFormats(SupportedFormats.jsonFormat())\n            .outputStrategy(OutputStrategies.keep())\n\n            .build();\n')),(0,a.kt)("h3",{id:"specifying-semantics"},"Specifying semantics"),(0,a.kt)("p",null,"For some algorithms, only specifying the datatype is not sufficient. Let's consider a geofencing algorithm that detects the precense some geospatial coordinate (e.g., from a vehicle) within a given location."),(0,a.kt)("p",null,"You could specify something like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},'    StreamRequirementsBuilder\n    .create()\n    .requiredPropertyWithUnaryMapping(EpRequirements.doubleEp(), Labels.from("mapping-latitude", "Latitude", ""), PropertyScope.NONE)\n    .requiredPropertyWithUnaryMapping(EpRequirements.doubleEp(), Labels.from("mapping-longitude", "Longitude", ""), PropertyScope.NONE)\n    .build()\n')),(0,a.kt)("p",null,"However, this would allow users to create strange pipelines as users could connect any stream containing a double value to our geofencing algorithm.\nTo avoid such situations, you can also specify requirements based on the semantics of a field:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},'    StreamRequirementsBuilder\n    .create()\n    .requiredPropertyWithUnaryMapping(EpRequirements.domainPropertyReq(SO.Latitude), Labels.from("mapping-latitude", "Latitude", ""), PropertyScope.NONE)\n    .requiredPropertyWithUnaryMapping(EpRequirements.domainPropertyReq(SO.Longitude), Labels.from("mapping-longitude", "Longitude", ""), PropertyScope.NONE)\n    .build()\n')),(0,a.kt)("p",null,"Note that in this case, we make use of Schema.org's ",(0,a.kt)("inlineCode",{parentName:"p"},"Latitude")," concept (",(0,a.kt)("a",{parentName:"p",href:"https://schema.org/latitude"},"https://schema.org/latitude"),"). StreamPipes already includes popular vocabularies for specifying semantics. You are also free to use your own vocabularies."),(0,a.kt)("h2",{id:"requirements-on-lists"},"Requirements on lists"),(0,a.kt)("p",null,"Similarly to primitive requirements, you can define processors that require data streams with list fields, see the following examples:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},'@Override\n  public DataProcessorDescription declareModel() {\n    return ProcessingElementBuilder.create("org.streampipes.examples.requirements" +\n            ".list", "List requirements specification examples", "")\n            .requiredStream(StreamRequirementsBuilder.\n                    create()\n                    .requiredProperty(EpRequirements.listRequirement(Datatypes.Integer))\n                    .requiredProperty(EpRequirements.listRequirement(Datatypes.Double))\n                    .requiredProperty(EpRequirements.listRequirement(Datatypes.Boolean))\n                    .requiredProperty(EpRequirements.listRequirement(Datatypes.String))\n                    .build())\n\n\n            .supportedProtocols(SupportedProtocols.kafka())\n            .supportedFormats(SupportedFormats.jsonFormat())\n            .outputStrategy(OutputStrategies.keep())\n\n            .build();\n  }\n')),(0,a.kt)("h2",{id:"requirements-on-nested-properties"},"Requirements on nested properties"),(0,a.kt)("p",null,"(coming soon, see the Javadoc for now)"))}f.isMDXComponent=!0}}]);