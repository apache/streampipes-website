"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[19735],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>h});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var p=a.createContext({}),d=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=d(e.components);return a.createElement(p.Provider,{value:t},e.children)},l="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,p=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),l=d(n),m=r,h=l["".concat(p,".").concat(m)]||l[m]||u[m]||i;return n?a.createElement(h,o(o({ref:t},c),{},{components:n})):a.createElement(h,o({ref:t},c))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=m;var s={};for(var p in t)hasOwnProperty.call(t,p)&&(s[p]=t[p]);s.originalType=e,s[l]="string"==typeof e?e:r,o[1]=s;for(var d=2;d<i;d++)o[d]=n[d];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},5935:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>p,default:()=>h,frontMatter:()=>s,metadata:()=>d,toc:()=>l});var a=n(87462),r=n(63366),i=(n(67294),n(3905)),o=["components"],s={id:"dev-guide-introduction",title:"Introduction",sidebar_label:"Introduction"},p=void 0,d={unversionedId:"dev-guide-introduction",id:"version-0.92.0/dev-guide-introduction",title:"Introduction",description:"StreamPipes is an open platform which can be easily extended at runtime by adding new data streams, data processors and data sinks.",source:"@site/versioned_docs/version-0.92.0/dev-guide-introduction.md",sourceDirName:".",slug:"/dev-guide-introduction",permalink:"/docs/dev-guide-introduction",draft:!1,tags:[],version:"0.92.0",lastUpdatedBy:"Dominik Riemer",lastUpdatedAt:1688317119,formattedLastUpdatedAt:"Jul 2, 2023",frontMatter:{id:"dev-guide-introduction",title:"Introduction",sidebar_label:"Introduction"}},c={},l=[{value:"Concepts",id:"concepts",level:2},{value:"Data Stream",id:"data-stream",level:3},{value:"Data Processor",id:"data-processor",level:3},{value:"Data Sink",id:"data-sink",level:3},{value:"Static Property",id:"static-property",level:3},{value:"Output Strategy",id:"output-strategy",level:3},{value:"Clients",id:"clients",level:2}],u={toc:l},m="wrapper";function h(e){var t=e.components,n=(0,r.Z)(e,o);return(0,i.kt)(m,(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"StreamPipes is an open platform which can be easily extended at runtime by adding new data streams, data processors and data sinks.\nWhen developing new components, usually multiple elements, called ",(0,i.kt)("em",{parentName:"p"},"pipeline elements"),", are bundled into a self-contained ",(0,i.kt)("em",{parentName:"p"},"pipeline element container"),". This container is deployed as a standalone microservice. This service is self-descriptive and exposes its description (see below for a detailed explanation) to the StreamPipes management backend. Once the service is deployed, it can be installed using the StreamPipes UI and all elements provided by this service are ready to be used as part of new pipelines."),(0,i.kt)("p",null,"To ease the extension of StreamPipes, we provide a powerful Software Development Kit (SDK) that allows you to define new pipeline elements for your StreamPipes instance."),(0,i.kt)("h2",{id:"concepts"},"Concepts"),(0,i.kt)("p",null,"In this section, we briefly describe the main concepts of StreamPipes. Although it might give an abstract overview, we are sure that many concepts will be more clear once you've created your very first pipeline element yourself. So check out our tutorials!"),(0,i.kt)("h3",{id:"data-stream"},"Data Stream"),(0,i.kt)("p",null,"A ",(0,i.kt)("em",{parentName:"p"},"Data Stream")," is the main concept to describe the source of a pipeline. ",(0,i.kt)("em",{parentName:"p"},"DataStreams")," consist of\nan RDF ",(0,i.kt)("em",{parentName:"p"},"description")," (which will be generated automatically when using the SDK) and a runtime\n",(0,i.kt)("em",{parentName:"p"},"implementation"),". The description includes information on the ",(0,i.kt)("em",{parentName:"p"},"schema")," of a data stream, e.g., measurement properties the payload of a stream provides.\nFurthermore, the description contains information on the ",(0,i.kt)("em",{parentName:"p"},"grounding"),", such as the transport format (e.g., JSON) and transport protoocol (e.g., MQTT or Kafka).\nOne or more data streams are assigned to a ",(0,i.kt)("em",{parentName:"p"},"Data Source")," to improve discovery of existing streams."),(0,i.kt)("h3",{id:"data-processor"},"Data Processor"),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Data Processors")," transform on or more input event streams to an output event stream. Data processors can be stateless (e.g., filter operations on every event of an input stream) or stateful (e.g., time-based aggregations using sliding windows).\nSimilar to data streams, processors consist of an RDF ",(0,i.kt)("em",{parentName:"p"},"description")," and a corresponding ",(0,i.kt)("em",{parentName:"p"},"implementation"),". The description is being used by the StreamPipes backend in order to determine the compatibility of a data processor and an input event stream and includes information the required minimum event schema as well as required user input and the definition of the output event stream."),(0,i.kt)("p",null,"The implementation of a data processor can be defined using a set of provided ",(0,i.kt)("em",{parentName:"p"},"runtime wrappers"),". These wrappers define where computation logic actually takes place once a pipeline was started. We currently provide runtime wrappers for various Big Data processing engines (e.g., Apache Flink) and lightweight standalone processors."),(0,i.kt)("h3",{id:"data-sink"},"Data Sink"),(0,i.kt)("p",null,"The concept of ",(0,i.kt)("em",{parentName:"p"},"Data Sinks")," is very similar to the concept of data processors with the exception that sinks do not produce any output streams.\nTherefore, sinks are used in StreamPipes to mark the end of a pipeline and reflect 3rd party applications, notifications or dashboard components."),(0,i.kt)("h3",{id:"static-property"},"Static Property"),(0,i.kt)("p",null,"Some data processors or data sinks might require input from users when pipelines are created using these elements.\nFor instance, a generic filter component might require information on the filter operation and a threshold value.\nSuch required user input can be modeled by defining ",(0,i.kt)("em",{parentName:"p"},"static properties"),". Static properties can be defined in many ways, e.g., plain text input, selections (e.g., radio buttons) or can be linked to separately stored domain knowledge.\nThe SDK contains many convenient functions that help you defining static properties."),(0,i.kt)("h3",{id:"output-strategy"},"Output Strategy"),(0,i.kt)("p",null,"As mentioned above, data processors also define the output event schema. However, as data processors in StreamPipes are often generic and can therefore be linked to any event stream that matches the input requirement of a data processor, the exact output schema is not known in the development phase when a data processor is defined.\nTherefore, data processors define their output using ",(0,i.kt)("em",{parentName:"p"},"output strategies"),". Such strategies describe the transformation process, i.e., how an input stream is transformed to an output stream.\nMultiple pre-defined output strategies exist that you can choose depending on the behaviour of a data processor.\nFor instance, the output schema of a filter component is usually similar to the input schema, so you would use a ",(0,i.kt)("em",{parentName:"p"},"KeepOutputStrategy"),".\nOn the other hand, an enrichment component usually adds additional properties to an input schema - this can be defined using a ",(0,i.kt)("em",{parentName:"p"},"AppendOutputStrategy"),".\nSometimes you want to let the user define the output schema. In this case, a ",(0,i.kt)("em",{parentName:"p"},"CustomOutputStrategy")," can be defined."),(0,i.kt)("h2",{id:"clients"},"Clients"),(0,i.kt)("p",null,"As stated in the beginning, pipeline element containers are deployed as self-contained microservices. The client types describes the environment this service is running in.\nCurrently supported clients are ",(0,i.kt)("em",{parentName:"p"},"standalone"),", which defines a standalone service that contains both the description and implementation part (which is often submitted to a computing cluster prior to pipeline execution) in addition to an embedded Jetty web server which creates a fat jar file, and ",(0,i.kt)("em",{parentName:"p"},"embedded"),", which creates a war file that can be imported into an existing application server."))}h.isMDXComponent=!0}}]);