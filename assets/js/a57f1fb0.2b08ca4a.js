"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[63730],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>h});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var p=a.createContext({}),l=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=l(e.components);return a.createElement(p.Provider,{value:t},e.children)},c="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,p=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),c=l(n),m=r,h=c["".concat(p,".").concat(m)]||c[m]||u[m]||i;return n?a.createElement(h,o(o({ref:t},d),{},{components:n})):a.createElement(h,o({ref:t},d))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=m;var s={};for(var p in t)hasOwnProperty.call(t,p)&&(s[p]=t[p]);s.originalType=e,s[c]="string"==typeof e?e:r,o[1]=s;for(var l=2;l<i;l++)o[l]=n[l];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},91836:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>p,default:()=>h,frontMatter:()=>s,metadata:()=>l,toc:()=>c});var a=n(87462),r=n(63366),i=(n(67294),n(3905)),o=["components"],s={id:"extend-tutorial-data-processors",title:"Tutorial: Data Processors",sidebar_label:"Tutorial: Data Processors"},p=void 0,l={unversionedId:"extend-tutorial-data-processors",id:"extend-tutorial-data-processors",title:"Tutorial: Data Processors",description:"In this tutorial, we will add a new data processor.",source:"@site/../docs/06_extend-tutorial-data-processors.md",sourceDirName:".",slug:"/extend-tutorial-data-processors",permalink:"/docs/next/extend-tutorial-data-processors",draft:!1,tags:[],version:"current",lastUpdatedBy:"Dominik Riemer",lastUpdatedAt:1689164473,formattedLastUpdatedAt:"Jul 12, 2023",sidebarPosition:6,frontMatter:{id:"extend-tutorial-data-processors",title:"Tutorial: Data Processors",sidebar_label:"Tutorial: Data Processors"},sidebar:"documentation",previous:{title:"Tutorial: Adapters",permalink:"/docs/next/extend-tutorial-adapters"},next:{title:"Tutorial: Data Sinks",permalink:"/docs/next/extend-tutorial-data-sinks"}},d={},c=[{value:"Objective",id:"objective",level:2},{value:"Project setup",id:"project-setup",level:2},{value:"Adding data processor requirements",id:"adding-data-processor-requirements",level:2},{value:"Pipeline element invocation",id:"pipeline-element-invocation",level:2},{value:"Adding an implementation",id:"adding-an-implementation",level:2},{value:"Registering the pipeline element",id:"registering-the-pipeline-element",level:2},{value:"Starting the service",id:"starting-the-service",level:2},{value:"Read more",id:"read-more",level:2}],u={toc:c},m="wrapper";function h(e){var t=e.components,n=(0,r.Z)(e,o);return(0,i.kt)(m,(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"In this tutorial, we will add a new data processor."),(0,i.kt)("p",null,"From an architectural point of view, we will create a self-contained service that includes the description of the data\nprocessor and an implementation."),(0,i.kt)("h2",{id:"objective"},"Objective"),(0,i.kt)("p",null,"We are going to create a new data processor that realizes a simple geofencing algorithm - we detect vehicles that enter\na specified radius around a user-defined location.\nThis pipeline element will be a generic element that works with any event stream that provides geospatial coordinates in\nform of a latitude/longitude pair."),(0,i.kt)("p",null,"The algorithm outputs every location event once the position has entered the geofence."),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"The implementation in this tutorial is pretty simple - our processor will fire an event every time the GPS location is\ninside the geofence.\nIn a real-world application, you would probably want to define a pattern that recognizes the ",(0,i.kt)("em",{parentName:"p"},"first")," event a vehicle\nenters the geofence."),(0,i.kt)("p",{parentName:"admonition"},"This can be easily done using a CEP library.")),(0,i.kt)("h2",{id:"project-setup"},"Project setup"),(0,i.kt)("p",null,"Instead of creating a new project from scratch, we recommend to use the Maven archetype to create a new project\nskeleton (streampipes-archetype-extensions-jvm).\nEnter the following command in a command line of your choice (Apache Maven needs to be installed):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"mvn archetype:generate \\\n-DarchetypeGroupId=org.apache.streampipes -DarchetypeArtifactId=streampipes-archetype-extensions-jvm \\\n-DarchetypeVersion=0.70.0 -DgroupId=my.groupId \\\n-DartifactId=my-example -DclassNamePrefix=MyExample -DpackageName=mypackagename\n")),(0,i.kt)("p",null,"You will see a project structure similar to the structure shown in the ",(0,i.kt)("a",{parentName:"p",href:"/docs/next/extend-archetypes"},"archetypes")," section."),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"Besides the basic project skeleton, the sample project also includes an example Dockerfile you can use to package your\napplication into a Docker container.")),(0,i.kt)("p",null,"Now you're ready to create your first data processor for StreamPipes!"),(0,i.kt)("h2",{id:"adding-data-processor-requirements"},"Adding data processor requirements"),(0,i.kt)("p",null,"First, we will add a new stream requirement.\nCreate a new class ",(0,i.kt)("inlineCode",{parentName:"p"},"GeofencingProcessor")," which should look as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'package org.apache.streampipes.pe.example;\n\nimport org.apache.streampipes.commons.exceptions.SpRuntimeException;\nimport org.apache.streampipes.model.DataProcessorType;\nimport org.apache.streampipes.model.graph.DataProcessorDescription;\nimport org.apache.streampipes.model.runtime.Event;\nimport org.apache.streampipes.sdk.builder.ProcessingElementBuilder;\nimport org.apache.streampipes.sdk.builder.StreamRequirementsBuilder;\nimport org.apache.streampipes.sdk.helpers.EpRequirements;\nimport org.apache.streampipes.sdk.helpers.Labels;\nimport org.apache.streampipes.sdk.helpers.Locales;\nimport org.apache.streampipes.sdk.helpers.OutputStrategies;\nimport org.apache.streampipes.sdk.utils.Assets;\nimport org.apache.streampipes.wrapper.context.EventProcessorRuntimeContext;\nimport org.apache.streampipes.wrapper.routing.SpOutputCollector;\nimport org.apache.streampipes.wrapper.standalone.ProcessorParams;\nimport org.apache.streampipes.wrapper.standalone.StreamPipesDataProcessor;\n\npublic class GeofencingProcessor extends StreamPipesDataProcessor {\n\n  private static final String LATITUDE_CENTER = "latitude-center";\n  private static final String LONGITUDE_CENTER = "longitude-center";\n\n  @Override\n  public DataProcessorDescription declareModel() {\n    return ProcessingElementBuilder.create("org.apache.streampipes.tutorial-geofencing")\n        .category(DataProcessorType.ENRICH)\n        .withAssets(Assets.DOCUMENTATION, Assets.ICON)\n        .build();\n  }\n\n  @Override\n  public void onInvocation(ProcessorParams parameters, SpOutputCollector spOutputCollector, EventProcessorRuntimeContext runtimeContext) throws SpRuntimeException {\n\n  }\n\n  @Override\n  public void onEvent(Event event, SpOutputCollector collector) throws SpRuntimeException {\n\n  }\n\n  @Override\n  public void onDetach() throws SpRuntimeException {\n\n  }\n}\n\n\n')),(0,i.kt)("p",null,"In this class, we need to implement three methods: The ",(0,i.kt)("inlineCode",{parentName:"p"},"declareModel")," method is used to define abstract stream\nrequirements such as event properties that must be present in any input stream that is later connected to the element\nusing the StreamPipes UI.\nThe second method, ",(0,i.kt)("inlineCode",{parentName:"p"},"onInvocation")," is triggered once a pipeline is started. Finally, the ",(0,i.kt)("inlineCode",{parentName:"p"},"onEvent")," method"),(0,i.kt)("p",null,"Similar to data sources, the SDK provides a builder class to generate the description for data processors.\nDelete the content within the ",(0,i.kt)("inlineCode",{parentName:"p"},"declareModel")," method and add the following lines to the ",(0,i.kt)("inlineCode",{parentName:"p"},"declareModel")," method:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'return ProcessingElementBuilder.create("org.apache.streampipes.tutorial.geofencing","Geofencing","A simple geofencing data processor")\n')),(0,i.kt)("p",null,"This creates a new data processor with the ID, title and description assigned to the element builder.\nNext, we add some ",(0,i.kt)("em",{parentName:"p"},"stream requirements")," to the description. As we'd like to develop a generic pipeline element that\nworks with any event that provides a lat/lng pair, we define two stream requirements as stated below:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'.requiredStream(StreamRequirementsBuilder\n    .create()\n    .requiredPropertyWithUnaryMapping(EpRequirements.domainPropertyReq(Geo.lat),\n    Labels.from("latitude-field","Latitude","The event "+\n    "property containing the latitude value"),PropertyScope.MEASUREMENT_PROPERTY)\n    .requiredPropertyWithUnaryMapping(EpRequirements.domainPropertyReq(Geo.lng),\n    Labels.from("longitude-field","Longitude","The event "+\n    "property containing the longitude value"),PropertyScope.MEASUREMENT_PROPERTY)\n    .build())\n')),(0,i.kt)("p",null,"The first line, ",(0,i.kt)("inlineCode",{parentName:"p"},".requiredStream()")," defines that we want a data processor with exactly one input stream. Adding more\nstream requirements would create elements with multiple input connectors in StreamPipes.\nStream requirements can be assigned by using the ",(0,i.kt)("inlineCode",{parentName:"p"},"StreamRequirementsBuilder")," class.\nIn our example, we define two requirements, so-called ",(0,i.kt)("em",{parentName:"p"},"domain property requirements"),". In contrast to ",(0,i.kt)("em",{parentName:"p"},"data type\nrequirements")," where we'd expect an event property with a field of a specific data type (e.g., float), domain property\nrequirements expect a specific domain property, e.g., from a vocabulary such as the WGS84 Geo vocab."),(0,i.kt)("p",null,"Once a pipeline is deployed, we are interested in the actual field (and its field name) that contains the latitude and\nlongitude values.\nIn some cases, there might me more than one field that satisfies a property requirement and we would like users to\nselect the property the geofencing component should operate on.\nTherefore, our example uses the method ",(0,i.kt)("inlineCode",{parentName:"p"},"requiredPropertyWithUnaryMapping"),", which will map a requirement to a real event\nproperty of an input stream and let the user choose the appropriate field in the StreamPipes UI when pipelines are\ndefined."),(0,i.kt)("p",null,"Finally, the ",(0,i.kt)("inlineCode",{parentName:"p"},"PropertyScope")," indicates that the required property is a measurement value (in contrast to a dimension\nvalue). This allows us later to provide improved user guidance in the pipeline editor."),(0,i.kt)("p",null,"Besides requirements, users should be able to define the center coordinate of the Geofence and the size of the fence\ndefined as a radius around the center in meters.\nThe radius can be defined by adding a simple required text field to the description:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'.requiredIntegerParameter("radius","Geofence Size","The size of the circular geofence in meters.",0,1000,1)\n')),(0,i.kt)("p",null,"Similar to mapping properties, text parameters have an internalId (radius), a label and a description.\nIn addition, we can assign a ",(0,i.kt)("em",{parentName:"p"},"value specification")," to the parameter indicating the value range we support.\nOur example supports a radius value between 0 and 1000 with a granularity of 1.\nIn the StreamPipes UI, a required text parameter is rendered as a text input field, in case we provide an optional value\nspecification, a slider input is automatically generated."),(0,i.kt)("p",null,"Such user-defined parameters are called ",(0,i.kt)("em",{parentName:"p"},"static properties"),". There are many different types of static properties (see\nthe ",(0,i.kt)("a",{parentName:"p",href:"/docs/next/extend-sdk-static-properties"},"Processor SDK")," for an overview)."),(0,i.kt)("p",null,"In this example, we'll further add two very simple input fields to let users provide latitude and longitude of the\ngeofence center."),(0,i.kt)("p",null,"Add the following line to the ",(0,i.kt)("inlineCode",{parentName:"p"},"declareModel")," method:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'   .requiredFloatParameter(Labels.from(LATITUDE_KEY,"Latitude","The latitude value"))\n    .requiredFloatParameter(Labels.from(LONGITUDE_KEY,"Longitude","The longitude value"))\n\n')),(0,i.kt)("p",null,"Now we need to define the output of our Geofencing pipeline element.\nAs explained in the first section, the element should fire every time some geo-located entity arrives within the defined\ngeofence.\nTherefore, the processor outputs the same schema as it receives as an input.\nAlthough we don't know the exact input right now as it depends on the stream users connect in StreamPipes when creating\npipelines, we can define an ",(0,i.kt)("em",{parentName:"p"},"output strategy")," as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},".outputStrategy(OutputStrategies.keep())\n")),(0,i.kt)("p",null,"This defines a ",(0,i.kt)("em",{parentName:"p"},"KeepOutputStrategy"),", i.e., the input event schema is not modified by the processor.\nThere are many more output strategies you can define depending on the functionality you desire, e.g., ",(0,i.kt)("em",{parentName:"p"},"AppendOutput")," for\ndefining a processor that enriches events or ",(0,i.kt)("em",{parentName:"p"},"CustomOutput")," in case you would like users to select the output by\nthemselves."),(0,i.kt)("p",null,"That's it! We've now defined input requirements, required user input and an output strategy.\nIn the next section, you will learn how to extract these parameters once the pipeline element is invoked after a\npipeline was created."),(0,i.kt)("h2",{id:"pipeline-element-invocation"},"Pipeline element invocation"),(0,i.kt)("p",null,"Once users start a pipeline that uses our geofencing component, the ",(0,i.kt)("em",{parentName:"p"},"onInvocation")," method in our class is called. The\nclass ",(0,i.kt)("inlineCode",{parentName:"p"},"ProcessorParams")," includes convenient access to user-configured parameters a users has selected in the pipeline\neditor and information on the acutal streams that are connected to the pipeline element."),(0,i.kt)("p",null,"Next, we are interested in the fields of the input event stream that contains the latitude and longitude value we would\nlike to compute against the geofence center location as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'String latitudeFieldName=parameters.extractor().mappingPropertyValue("latitude-field");\n    String longitudeFieldName=parameters.extractor().mappingPropertyValue("longitude-field");\n')),(0,i.kt)("p",null,"We use the same ",(0,i.kt)("inlineCode",{parentName:"p"},"internalId")," we've used to define the mapping property requirements in the ",(0,i.kt)("inlineCode",{parentName:"p"},"declareModel")," method."),(0,i.kt)("p",null,"Next, for extracting the geofence center coordinates, add to class variables centerLatitude and centerLongitude and\nassign the selected values using the following statements:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"this.centerLatitude=parameters.extractor().singleValueParameter(LATITUDE_CENTER,Float.class);\n    this.centerLongitude=parameters.extractor().singleValueParameter(LONGITUDE_CENTER,Float.class);\n")),(0,i.kt)("p",null,"The radius value can be extracted as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'int radius=parameters.extractor().singleValueParameter("radius",Float.class);\n')),(0,i.kt)("p",null,"Great! That's all we need to describe a data processor for usage in StreamPipes. Your processor class should look as\nfollows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'package org.apache.streampipes.pe.example;\n\nimport org.apache.streampipes.commons.exceptions.SpRuntimeException;\nimport org.apache.streampipes.model.DataProcessorType;\nimport org.apache.streampipes.model.graph.DataProcessorDescription;\nimport org.apache.streampipes.model.runtime.Event;\nimport org.apache.streampipes.model.schema.PropertyScope;\nimport org.apache.streampipes.sdk.builder.ProcessingElementBuilder;\nimport org.apache.streampipes.sdk.builder.StreamRequirementsBuilder;\nimport org.apache.streampipes.sdk.helpers.EpRequirements;\nimport org.apache.streampipes.sdk.helpers.Labels;\nimport org.apache.streampipes.sdk.helpers.Locales;\nimport org.apache.streampipes.sdk.helpers.OutputStrategies;\nimport org.apache.streampipes.sdk.utils.Assets;\nimport org.apache.streampipes.vocabulary.Geo;\nimport org.apache.streampipes.wrapper.context.EventProcessorRuntimeContext;\nimport org.apache.streampipes.wrapper.routing.SpOutputCollector;\nimport org.apache.streampipes.wrapper.standalone.ProcessorParams;\nimport org.apache.streampipes.wrapper.standalone.StreamPipesDataProcessor;\n\npublic class GeofencingProcessor extends StreamPipesDataProcessor {\n\n  private static final String LATITUDE_CENTER = "latitude-center";\n  private static final String LONGITUDE_CENTER = "longitude-center";\n\n  private float centerLatitude;\n  private float centerLongitude;\n  private String latitudeFieldName;\n  private String longitudeFieldName;\n\n  private int radius;\n\n  @Override\n  public DataProcessorDescription declareModel() {\n    return ProcessingElementBuilder.create("org.streampipes.tutorial-geofencing")\n        .category(DataProcessorType.ENRICH)\n        .withAssets(Assets.DOCUMENTATION, Assets.ICON)\n        .withLocales(Locales.EN)\n        .requiredStream(StreamRequirementsBuilder\n            .create()\n            .requiredPropertyWithUnaryMapping(EpRequirements.domainPropertyReq(Geo.lat),\n                Labels.from("latitude-field", "Latitude", "The event " +\n                    "property containing the latitude value"), PropertyScope.MEASUREMENT_PROPERTY)\n            .requiredPropertyWithUnaryMapping(EpRequirements.domainPropertyReq(Geo.lng),\n                Labels.from("longitude-field", "Longitude", "The event " +\n                    "property containing the longitude value"), PropertyScope.MEASUREMENT_PROPERTY)\n            .build())\n        .outputStrategy(OutputStrategies.keep())\n        .requiredIntegerParameter("radius", "Geofence Size", "The size of the circular geofence in meters.", 0, 1000, 1)\n        .requiredFloatParameter(Labels.from(LATITUDE_CENTER, "Latitude", "The latitude value"))\n        .requiredFloatParameter(Labels.from(LONGITUDE_CENTER, "Longitude", "The longitude value"))\n        .build();\n  }\n\n  @Override\n  public void onInvocation(ProcessorParams parameters,\n                           SpOutputCollector spOutputCollector,\n                           EventProcessorRuntimeContext runtimeContext) throws SpRuntimeException {\n    this.centerLatitude = parameters.extractor().singleValueParameter(LATITUDE_CENTER, Float.class);\n    this.centerLongitude = parameters.extractor().singleValueParameter(LONGITUDE_CENTER, Float.class);\n    this.latitudeFieldName = parameters.extractor().mappingPropertyValue("latitude-field");\n    this.longitudeFieldName = parameters.extractor().mappingPropertyValue("longitude-field");\n    this.radius = parameters.extractor().singleValueParameter("radius", Integer.class);\n  }\n\n  @Override\n  public void onEvent(Event event, SpOutputCollector collector) throws SpRuntimeException {\n\n  }\n\n  @Override\n  public void onDetach() throws SpRuntimeException {\n\n  }\n}\n\n\n')),(0,i.kt)("h2",{id:"adding-an-implementation"},"Adding an implementation"),(0,i.kt)("p",null,"Everything we need to do now is to add an implementation."),(0,i.kt)("p",null,"Add the following piece of code to the onEvent method, which realizes the Geofencing functionality:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"\n@Override\npublic void onEvent(Event event,SpOutputCollector collector)throws SpRuntimeException{\n    float latitude=event.getFieldBySelector(latitudeFieldName).getAsPrimitive().getAsFloat();\n    float longitude=event.getFieldBySelector(longitudeFieldName).getAsPrimitive().getAsFloat();\n\n    float distance=distFrom(latitude,longitude,centerLatitude,centerLongitude);\n\n    if(distance<=radius){\n    collector.collect(event);\n    }\n    }\n\npublic static float distFrom(float lat1,float lng1,float lat2,float lng2){\n    double earthRadius=6371000;\n    double dLat=Math.toRadians(lat2-lat1);\n    double dLng=Math.toRadians(lng2-lng1);\n    double a=Math.sin(dLat/2)*Math.sin(dLat/2)+\n    Math.cos(Math.toRadians(lat1))*Math.cos(Math.toRadians(lat2))*\n    Math.sin(dLng/2)*Math.sin(dLng/2);\n    double c=2*Math.atan2(Math.sqrt(a),Math.sqrt(1-a));\n    return(float)(earthRadius*c);\n    }\n\n    }\n")),(0,i.kt)("p",null,"We won't go into details here as this isn't StreamPipes-related code, but in general the class extracts latitude and\nlongitude fields from the input event (which is provided as a map data type) and calculates the distance between the\ngeofence center and these coordinates.\nIf the distance is below the given radius, the event is forwarded to the next operator."),(0,i.kt)("p",null,"See the ",(0,i.kt)("a",{parentName:"p",href:"/docs/next/extend-sdk-event-model"},"event model")," guide to learn how to extract parameters from events."),(0,i.kt)("h2",{id:"registering-the-pipeline-element"},"Registering the pipeline element"),(0,i.kt)("p",null,"The final step is to register the data processor in the ",(0,i.kt)("inlineCode",{parentName:"p"},"Init")," method. Add the following line to\nthe ",(0,i.kt)("inlineCode",{parentName:"p"},"SpServiceDefinitionBuilder"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"}," .registerPipelineElement(new GeofencingProcessor())\n")),(0,i.kt)("h2",{id:"starting-the-service"},"Starting the service"),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"Once you start the service, it will register in StreamPipes with the hostname. The hostname will be auto-discovered and\nshould work out-of-the-box.\nIn some cases, the detected hostname is not resolvable from within a container (where the core is running). In this\ncase, provide a SP_HOST environment variable to override the auto-discovery.")),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"The default port of all pipeline element services as defined in the ",(0,i.kt)("inlineCode",{parentName:"p"},"create")," method is port 8090.\nIf you'd like to run multiple services at the same time on your development machine, change the port here. As an\nalternative, you can also provide an env variable ",(0,i.kt)("inlineCode",{parentName:"p"},"SP_PORT")," which overrides the port settings. This is useful to use\ndifferent configs for dev and prod environments.")),(0,i.kt)("p",null,"Now we are ready to start our service!"),(0,i.kt)("p",null,"Configure your IDE to provide an environment variable called ",(0,i.kt)("inlineCode",{parentName:"p"},"SP_DEBUG")," with value ",(0,i.kt)("inlineCode",{parentName:"p"},"true")," when starting the project."),(0,i.kt)("p",null,"Execute the main method in the class ",(0,i.kt)("inlineCode",{parentName:"p"},"Init")," we've just created."),(0,i.kt)("p",null,"The service automatically registers itself in StreamPipes.\nTo install the just created element, open the StreamPipes UI and follow the manual provided in\nthe ",(0,i.kt)("a",{parentName:"p",href:"/docs/next/use-install-pipeline-elements"},"user guide"),"."),(0,i.kt)("h2",{id:"read-more"},"Read more"),(0,i.kt)("p",null,"Congratulations! You've just created your first data processor for StreamPipes.\nThere are many more things to explore and data processors can be defined in much more detail using multiple wrappers.\nFollow our ",(0,i.kt)("a",{parentName:"p",href:"/docs/next/extend-sdk-static-properties"},"SDK guide")," to see what's possible!"))}h.isMDXComponent=!0}}]);